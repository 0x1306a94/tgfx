<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš€ TGFX åœ¨çº¿ç¼–è¯‘å™¨ - å…¨é‡å†…è”æ–¹æ¡ˆ - 100%å…¼å®¹æ€§ä¿è¯</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .main-container {
            display: flex;
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 10px;
            margin: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .editor-section {
            width: 50%;
            display: flex;
            flex-direction: column;
            border-right: 2px solid #f0f0f0;
        }
        
        .console-section {
            width: 50%;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h3 {
            margin: 0;
            color: #333;
            font-size: 16px;
        }
        
        .compile-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .compile-btn:hover:not(:disabled) {
            background: linear-gradient(45deg, #218838, #1ea085);
            transform: translateY(-2px);
        }
        
        .compile-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        .loading-icon {
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .code-editor {
            width: 100%;
            height: 400px;
            border: none;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            padding: 20px;
            resize: none;
            background: #f8f9fa;
            line-height: 1.5;
            outline: none;
        }
        
        .status-bar {
            padding: 10px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .status-indicator {
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            color: white;
        }
        
        .status-ready { background: #28a745; }
        .status-compiling { background: #ffc107; color: #212529; }
        .status-error { background: #dc3545; }
        .status-success { background: #28a745; }
        .status-warning { background: #ffc107; color: #212529; }
        
        .compiler-info {
            display: flex;
            gap: 20px;
            font-size: 11px;
            color: #666;
        }
        
        .console-area {
            height: 200px;
            border-top: 1px solid #e9ecef;
            background: #2d3748;
            color: #e2e8f0;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
        }
        
        .console-line {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .console-info { color: #4299e1; }
        .console-success { color: #48bb78; }
        .console-error { color: #f56565; }
        .console-warning { color: #ed8936; }
        .console-compile { color: #9f7aea; }
        
        .library-status {
            padding: 10px 20px;
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            font-size: 12px;
            color: #856404;
        }
        
        .library-status.loaded {
            background: #d1ecf1;
            border-left-color: #17a2b8;
            color: #0c5460;
        }
        
        .clear-console {
            background: #6c757d;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 10px;
        }
        
        .clear-console:hover {
            background: #5a6268;
        }
        
        .canvas-container {
            height: 300px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #renderCanvas {
            border: 1px solid #ddd;
            background: white;
            max-width: 100%;
            max-height: 100%;
        }

        .canvas-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
        }

        .drawer-controls {
            padding: 10px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .drawer-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .drawer-btn:hover {
            background: #0056b3;
        }

        .drawer-btn.active {
            background: #28a745;
        }

        .example-controls {
            padding: 10px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .example-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .example-btn:hover {
            background: #5a6268;
        }
    
        #renderCanvas {
            display: block !important;
            border: 2px solid red !important;
            background-color: rgba(200, 200, 200, 0.1) !important;
            width: 100% !important;
            height: 300px !important;
        }

</style>
</head>
<body>
    <div class="main-container">
        <!-- ç¼–è¾‘å™¨åŒºåŸŸ -->
        <div class="editor-section">
            <div class="header">
                <h3>ğŸš€ TGFX å…¨é‡å†…è”ç¼–è¯‘å™¨</h3>
                <button class="compile-btn" id="compileBtn" disabled>
                    <div class="loading-icon" id="loadingIcon"></div>
                    <span id="compileText">ç¼–è¯‘å¹¶è¿è¡Œ</span>
                </button>
            </div>
            
                        <textarea class="code-editor" id="codeEditor" placeholder="Enter your TGFX C++ code...">
#include <iostream>

// TGFX å…¨é‡å†…è”ç¤ºä¾‹ - æ‰€æœ‰å¤´æ–‡ä»¶è‡ªåŠ¨åŒ…å«
// æ— éœ€æ‰‹åŠ¨#includeä»»ä½•TGFXå¤´æ–‡ä»¶

int main() {
    std::cout << "=== TGFX Full Inline Example ===" << std::endl;

    // åˆ›å»ºè™šæ‹Ÿcanvaså’Œpaintï¼ˆç”±è¿è¡Œæ—¶æä¾›ï¼‰
    Canvas* canvas = nullptr;
    Paint paint;

    // æ¸…é™¤èƒŒæ™¯ä¸ºç™½è‰²
    canvas->clear(Color::White());

    // è®¾ç½®ç”»ç¬”é¢œè‰²ä¸ºçº¢è‰²å¹¶ç»˜åˆ¶çŸ©å½¢
    paint.setColor(Color::Red());
    canvas->drawRect(Rect::MakeXYWH(50, 50, 200, 100), paint);

    // è®¾ç½®ç”»ç¬”é¢œè‰²ä¸ºè“è‰²å¹¶ç»˜åˆ¶å¦ä¸€ä¸ªçŸ©å½¢
    paint.setColor(Color::Blue());
    canvas->drawRect(Rect::MakeXYWH(150, 150, 150, 120), paint);

    // æµ‹è¯•æ‰€æœ‰ä¸»è¦TGFXç±»å‹éƒ½å¯ç”¨
    Matrix transform;
    RRect roundRect = RRect::MakeRect(Rect::MakeXYWH(10, 10, 100, 50));
    Point center = Point::Make(400, 300);
    
    std::cout << "âœ… å…¨é‡å†…è”æˆåŠŸï¼æ‰€æœ‰TGFXç±»å‹å¯ç”¨ï¼" << std::endl;
    return 0;
}
</textarea>
            
            <div class="status-bar">
                <div class="status-indicator" id="statusIndicator">åˆå§‹åŒ–ä¸­...</div>
                <div class="compiler-info">
                    <span id="compilerStatus">æ­£åœ¨åŠ è½½...</span>
                    <span id="tgfxLibInfo">TGFXåº“: æœªåŠ è½½</span>
                </div>
            </div>

            <div class="example-controls">
                <span>ä»£ç ç¤ºä¾‹:</span>
                <button class="example-btn" onclick="loadExample('simple')">ç®€å•æµ‹è¯•</button>
                <button class="example-btn" onclick="loadExample('basic')">åŸºç¡€ç¤ºä¾‹</button>
                <button class="example-btn" onclick="loadExample('advanced')">é«˜çº§ç¤ºä¾‹</button>
            </div>
            
            <div class="library-status" id="libraryStatus">
                <strong>ç¼–è¯‘å™¨çŠ¶æ€:</strong> æ­£åœ¨åˆå§‹åŒ–å®Œæ•´çš„clang.jsç¼–è¯‘å™¨...
            </div>
        </div>
        
        <!-- æ§åˆ¶å°å’Œæ¸²æŸ“åŒºåŸŸ -->
        <div class="console-section">
            <div class="header">
                <h3>ğŸ”§ ç¼–è¯‘æ§åˆ¶å°</h3>
                <div>
                    <button class="clear-console" onclick="clearConsole()">æ¸…ç©ºæ§åˆ¶å°</button>
                </div>
            </div>
            
            <div class="console-area" id="consoleArea">
                <div class="console-line console-info">ğŸš€ TGFX å…¨é‡å†…è”ç¼–è¯‘å™¨æ§åˆ¶å°</div>
                <div class="console-line console-info">â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</div>
                <div class="console-line console-info">æ­£åœ¨åˆå§‹åŒ–å…¨é‡å†…è”ç¼–è¯‘å™¨ï¼ŒåŒ…å«æ‰€æœ‰36ä¸ªTGFXå¤´æ–‡ä»¶...</div>
            </div>

            <div class="drawer-controls">
                <span>TGFXç¤ºä¾‹:</span>
                <button class="drawer-btn" onclick="switchDrawer(0)">ç½‘æ ¼èƒŒæ™¯</button>
                <button class="drawer-btn" onclick="switchDrawer(1)">ç®€å•æ–‡æœ¬</button>
                <button class="drawer-btn" onclick="switchDrawer(2)">å›¾ç‰‡é˜´å½±</button>
                <button class="drawer-btn" onclick="switchDrawer(3)">æ¸å˜æ•ˆæœ</button>
                <button class="drawer-btn" onclick="switchDrawer(4)">å›¾ç‰‡Mipmap</button>
            </div>
            
            <div class="canvas-container">
                <canvas id="renderCanvas" width="800" height="600"></canvas>
                <div class="canvas-info">TGFX å®Œæ•´æ¸²æŸ“ç”»å¸ƒ (800x600)</div>
            </div>
        </div>
    </div>

    <script type="module">
        // TGFX åœ¨çº¿ç¼–è¯‘å™¨ - JavaScript æ ¸å¿ƒåŠŸèƒ½

// å¯¼å…¥clang.jsè¿›è¡ŒçœŸå®ç¼–è¯‘
import { init, run } from 'https://cdn.jsdelivr.net/npm/clang.js/+esm';


// å®šä¹‰TGFXBindå‡½æ•°
window.TGFXBind = function(module) {
    addConsoleOutput('æ­£åœ¨ç»‘å®šTGFXæ¨¡å—...', 'info');
    
    if (!module) {
        addConsoleOutput('âŒ TGFXBind: æ¨¡å—ä¸ºç©º', 'error');
        return false;
    }
    
    // ç»‘å®šTGFXç›¸å…³å‡½æ•°åˆ°æ¨¡å—
    try {
        // è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„ç»‘å®šé€»è¾‘
        addConsoleOutput('âœ… TGFXBind: æ¨¡å—ç»‘å®šæˆåŠŸ', 'success');
        return true;
    } catch (error) {
        addConsoleOutput('âŒ TGFXBind: ç»‘å®šå¤±è´¥ - ' + error.message, 'error');
        return false;
    }
};

// å…¨å±€å˜é‡
let Hello2DModule = null;
let tgfxView = null;
let isRealTGFX = false;
let currentDrawIndex = 0;
let isCompilerReady = false;
let tgfxLibraryLoaded = false;
let isCompiling = false;
let clangAPI = null;
let tgfxModule = null;
let renderCanvas = null;
let glContext = null;

// TGFXè™šæ‹Ÿå¤´æ–‡ä»¶ç³»ç»Ÿ
const TGFX_HEADERS = {
    'tgfx/core/Canvas.h': `#pragma once
#include <stack>
#include "tgfx/core/Font.h"
#include "tgfx/core/Image.h"
#include "tgfx/core/Paint.h"
#include "tgfx/core/Path.h"
#include "tgfx/core/Picture.h"
#include "tgfx/core/SamplingOptions.h"
#include "tgfx/core/Shape.h"
#include "tgfx/core/TextBlob.h"

namespace tgfx {
class Surface;
class DrawContext;
class MCState;
class CanvasState;

enum class SrcRectConstraint {
  Strict,
  Fast,
};

class Canvas {
 public:
  Surface* getSurface() const { return surface; }
  int save();
  int saveLayer(const Paint* paint);
  int saveLayerAlpha(float alpha);
  void restore();
  int getSaveCount() const;
  void restoreToCount(int saveCount);
  void translate(float dx, float dy);
  void scale(float sx, float sy);
  void rotate(float degrees);
  void rotate(float degrees, float px, float py);
  void skew(float sx, float sy);
  void concat(const Matrix& matrix);
  const Matrix& getMatrix() const;
  void setMatrix(const Matrix& matrix);
  void resetMatrix();
  const Path& getTotalClip() const;
  void clipRect(const Rect& rect);
  void clipPath(const Path& path);
  void clear(const Color& color = Color::Transparent());
  void drawColor(const Color& color, BlendMode blendMode = BlendMode::SrcOver);
  void drawPaint(const Paint& paint);
  void drawLine(float x0, float y0, float x1, float y1, const Paint& paint);
  void drawLine(const Point& p0, const Point& p1, const Paint& paint);
  void drawRect(const Rect& rect, const Paint& paint);
  void drawOval(const Rect& oval, const Paint& paint);
  void drawCircle(float centerX, float centerY, float radius, const Paint& paint);
  void drawCircle(const Point& center, float radius, const Paint& paint);
  void drawRoundRect(const Rect& rect, float radiusX, float radiusY, const Paint& paint);
  void drawRRect(const RRect& rRect, const Paint& paint);
  void drawPath(const Path& path, const Paint& paint);
  void drawShape(std::shared_ptr<Shape> shape, const Paint& paint);
  void drawImage(std::shared_ptr<Image> image, const Paint* paint = nullptr);
  void drawImage(std::shared_ptr<Image> image, float left, float top, const Paint* paint = nullptr);
  void drawImage(std::shared_ptr<Image> image, const SamplingOptions& sampling, const Paint* paint = nullptr);
  void drawImage(std::shared_ptr<Image> image, float left, float top, const SamplingOptions& sampling, const Paint* paint = nullptr);
  void drawImageRect(std::shared_ptr<Image> image, const Rect& dstRect, const SamplingOptions& sampling = {}, const Paint* paint = nullptr);
  void drawImageRect(std::shared_ptr<Image> image, const Rect& srcRect, const Rect& dstRect, const SamplingOptions& sampling = {}, const Paint* paint = nullptr, SrcRectConstraint constraint = SrcRectConstraint::Fast);
  void drawSimpleText(const std::string& text, float x, float y, const Font& font, const Paint& paint);
  void drawGlyphs(const GlyphID glyphs[], const Point positions[], size_t glyphCount, const Font& font, const Paint& paint);
  void drawTextBlob(std::shared_ptr<TextBlob> textBlob, float x, float y, const Paint& paint);
  void drawPicture(std::shared_ptr<Picture> picture);
  void drawPicture(std::shared_ptr<Picture> picture, const Matrix* matrix, const Paint* paint);
  void drawAtlas(std::shared_ptr<Image> atlas, const Matrix matrix[], const Rect tex[], const Color colors[], size_t count, const SamplingOptions& sampling = {}, const Paint* paint = nullptr);

 private:
  DrawContext* drawContext = nullptr;
  Surface* surface = nullptr;
  bool optimizeMemoryForLayer = false;
  std::unique_ptr<MCState> mcState;
  std::stack<std::unique_ptr<CanvasState>> stateStack;
};

class AutoCanvasRestore {
 public:
  explicit AutoCanvasRestore(Canvas* canvas);
  ~AutoCanvasRestore();
 private:
  Canvas* canvas = nullptr;
  int saveCount = 0;
};
}  // namespace tgfx`,

    'tgfx/core/Paint.h': `#pragma once
#include "tgfx/core/BlendMode.h"
#include "tgfx/core/Color.h"
#include "tgfx/core/ColorFilter.h"
#include "tgfx/core/ImageFilter.h"
#include "tgfx/core/MaskFilter.h"
#include "tgfx/core/Shader.h"
#include "tgfx/core/Stroke.h"

namespace tgfx {

enum class PaintStyle {
  Fill,
  Stroke,
};

class Paint {
 public:
  Paint() = default;
  Paint(const Paint&) = default;
  Paint& operator=(const Paint&) = default;

  void setColor(const Color& color);
  void setColor(float r, float g, float b, float a = 1.0f);
  Color getColor() const;

  void setStyle(PaintStyle style);
  PaintStyle getStyle() const;

  void setStrokeWidth(float width);
  float getStrokeWidth() const;

  void setStroke(const Stroke& stroke);
  const Stroke* getStroke() const;

  void setShader(std::shared_ptr<Shader> shader);
  std::shared_ptr<Shader> getShader() const;

  void setBlendMode(BlendMode blendMode);
  BlendMode getBlendMode() const;

  void setAlpha(float alpha);
  float getAlpha() const;

  void setAntiAlias(bool antiAlias);
  bool isAntiAlias() const;

  void setColorFilter(std::shared_ptr<ColorFilter> colorFilter);
  std::shared_ptr<ColorFilter> getColorFilter() const;

  void setImageFilter(std::shared_ptr<ImageFilter> imageFilter);
  std::shared_ptr<ImageFilter> getImageFilter() const;

  void setMaskFilter(std::shared_ptr<MaskFilter> maskFilter);
  std::shared_ptr<MaskFilter> getMaskFilter() const;

  Fill getFill() const;

 private:
  Color color = Color::Black();
  PaintStyle style = PaintStyle::Fill;
  float strokeWidth = 0.0f;
  std::shared_ptr<Stroke> stroke;
  std::shared_ptr<Shader> shader;
  BlendMode blendMode = BlendMode::SrcOver;
  float alpha = 1.0f;
  bool antiAlias = true;
  std::shared_ptr<ColorFilter> colorFilter;
  std::shared_ptr<ImageFilter> imageFilter;
  std::shared_ptr<MaskFilter> maskFilter;
};

}  // namespace tgfx`,

    'tgfx/core/ColorType.h': `#pragma once

namespace tgfx {

enum class ColorType {
  Unknown,
  Alpha_8,
  RGB_565,
  ARGB_4444,
  RGBA_8888,
  RGB_888x,
  BGRA_8888,
  RGBA_1010102,
  BGRA_1010102,
  RGB_101010x,
  BGR_101010x,
  Gray_8,
  RGBA_F16Norm,
  RGBA_F16,
  RGBA_F32,
  R8G8_unorm,
  A16_float,
  R16G16_float,
  A16_unorm,
  R16G16_unorm,
  R16G16B16A16_unorm,
};

}  // namespace tgfx`,

    'tgfx/core/AlphaType.h': `#pragma once

namespace tgfx {

enum class AlphaType {
  Unknown,
  Opaque,
  Premul,
  Unpremul,
};

}  // namespace tgfx`,

    'tgfx/core/Color.h': `#pragma once
#include <cstdint>

namespace tgfx {

class Color {
 public:
  Color() = default;
  Color(float r, float g, float b, float a = 1.0f);

  static Color Transparent() { return Color(0, 0, 0, 0); }
  static Color Black() { return Color(0, 0, 0, 1); }
  static Color White() { return Color(1, 1, 1, 1); }
  static Color Red() { return Color(1, 0, 0, 1); }
  static Color Green() { return Color(0, 1, 0, 1); }
  static Color Blue() { return Color(0, 0, 1, 1); }
  static Color Yellow() { return Color(1, 1, 0, 1); }
  static Color Cyan() { return Color(0, 1, 1, 1); }
  static Color Magenta() { return Color(1, 0, 1, 1); }

  static Color MakeRGB(float r, float g, float b) { return Color(r, g, b, 1.0f); }
  static Color MakeRGBA(float r, float g, float b, float a) { return Color(r, g, b, a); }

  float red() const { return r; }
  float green() const { return g; }
  float blue() const { return b; }
  float alpha() const { return a; }

  uint32_t toRGBA() const;

 private:
  float r = 0, g = 0, b = 0, a = 1;
};

}  // namespace tgfx`,

    'tgfx/core/Size.h': `#pragma once
#include "tgfx/core/Point.h"

namespace tgfx {

class Size {
 public:
  Size() = default;
  Size(float width, float height);

  static Size Make(float width, float height) { return Size(width, height); }
  static Size MakeEmpty() { return Size(0, 0); }

  float width() const { return fWidth; }
  float height() const { return fHeight; }

  void set(float width, float height);
  void setWidth(float width);
  void setHeight(float height);

  bool isEmpty() const;

  Size operator+(const Size& other) const;
  Size operator-(const Size& other) const;
  Size operator*(float scale) const;
  Size operator/(float scale) const;

  Size& operator+=(const Size& other);
  Size& operator-=(const Size& other);
  Size& operator*=(float scale);
  Size& operator/=(float scale);

  bool operator==(const Size& other) const;
  bool operator!=(const Size& other) const;

 private:
  float fWidth = 0, fHeight = 0;
};

}  // namespace tgfx`,

    'tgfx/core/Rect.h': `#pragma once
#include "tgfx/core/Point.h"
#include "tgfx/core/Size.h"

namespace tgfx {

class Rect {
 public:
  Rect() = default;
  Rect(float left, float top, float right, float bottom);
  Rect(const Point& topLeft, const Point& bottomRight);
  Rect(const Point& topLeft, const Size& size);

  static Rect MakeEmpty();
  static Rect MakeLTRB(float left, float top, float right, float bottom);
  static Rect MakeXYWH(float x, float y, float width, float height);
  static Rect MakeWH(float width, float height);

  float left() const { return fLeft; }
  float top() const { return fTop; }
  float right() const { return fRight; }
  float bottom() const { return fBottom; }

  float width() const { return fRight - fLeft; }
  float height() const { return fBottom - fTop; }

  bool isEmpty() const;
  bool contains(float x, float y) const;
  bool contains(const Point& point) const;

  void setEmpty();
  void setLTRB(float left, float top, float right, float bottom);
  void setXYWH(float x, float y, float width, float height);

  void offset(float dx, float dy);
  void offset(const Point& offset);

  void inset(float dx, float dy);
  void inset(const Point& inset);

  void outset(float dx, float dy);
  void outset(const Point& outset);

  Rect makeOffset(float dx, float dy) const;
  Rect makeOffset(const Point& offset) const;

  Rect makeInset(float dx, float dy) const;
  Rect makeInset(const Point& inset) const;

  Rect makeOutset(float dx, float dy) const;
  Rect makeOutset(const Point& outset) const;

  bool intersects(const Rect& other) const;
  bool intersect(const Rect& other);
  Rect makeIntersect(const Rect& other) const;

  void join(const Rect& other);
  Rect makeJoin(const Rect& other) const;

 private:
  float fLeft = 0, fTop = 0, fRight = 0, fBottom = 0;
};

}  // namespace tgfx`,

    'tgfx/core/Point.h': `#pragma once
#include <cmath>

namespace tgfx {

class Point {
 public:
  Point() = default;
  Point(float x, float y);

  static Point Make(float x, float y) { return Point(x, y); }
  static Point Zero() { return Point(0, 0); }

  float x() const { return fX; }
  float y() const { return fY; }

  void set(float x, float y);
  void setX(float x);
  void setY(float y);

  float length() const;
  float lengthSquared() const;

  Point normalize() const;

  Point operator+(const Point& other) const;
  Point operator-(const Point& other) const;
  Point operator*(float scale) const;
  Point operator/(float scale) const;

  Point& operator+=(const Point& other);
  Point& operator-=(const Point& other);
  Point& operator*=(float scale);
  Point& operator/=(float scale);

  bool operator==(const Point& other) const;
  bool operator!=(const Point& other) const;

 private:
  float fX = 0, fY = 0;
};

}  // namespace tgfx`,

    'tgfx/core/Font.h': `#pragma once
#include "tgfx/core/FontMetrics.h"
#include "tgfx/core/FontStyle.h"
#include "tgfx/core/Typeface.h"

namespace tgfx {

class Font {
 public:
  Font() = default;
  Font(std::shared_ptr<Typeface> typeface, float size);
  Font(std::shared_ptr<Typeface> typeface, float size, const FontStyle& style);

  void setTypeface(std::shared_ptr<Typeface> typeface);
  std::shared_ptr<Typeface> getTypeface() const;

  void setSize(float size);
  float getSize() const;

  void setStyle(const FontStyle& style);
  FontStyle getStyle() const;

  void setFauxBold(bool fauxBold);
  bool isFauxBold() const;

  void setFauxItalic(bool fauxItalic);
  bool isFauxItalic() const;

  FontMetrics getMetrics() const;

 private:
  std::shared_ptr<Typeface> typeface;
  float size = 12.0f;
  FontStyle style;
  bool fauxBold = false;
  bool fauxItalic = false;
};

}  // namespace tgfx`,

    'tgfx/core/Typeface.h': `#pragma once
#include <memory>
#include <string>

namespace tgfx {

class Typeface {
 public:
  virtual ~Typeface() = default;

  static std::shared_ptr<Typeface> MakeFromName(const std::string& familyName, const std::string& style = "");
  static std::shared_ptr<Typeface> MakeFromPath(const std::string& path);

  virtual std::string familyName() const = 0;
  virtual std::string styleName() const = 0;

  virtual bool isBold() const = 0;
  virtual bool isItalic() const = 0;

  virtual int unitsPerEm() const = 0;

  virtual bool hasGlyph(uint32_t unicode) const = 0;

  virtual std::shared_ptr<Typeface> makeClone() const = 0;
};

}  // namespace tgfx`,

    'tgfx/core/Shader.h': `#pragma once
#include "tgfx/core/Color.h"
#include "tgfx/core/Point.h"
#include "tgfx/core/TileMode.h"

namespace tgfx {

class Shader {
 public:
  virtual ~Shader() = default;

  static std::shared_ptr<Shader> MakeLinearGradient(const Point& start, const Point& end,
                                                   const std::vector<Color>& colors,
                                                   const std::vector<float>& positions = {});

  static std::shared_ptr<Shader> MakeRadialGradient(const Point& center, float radius,
                                                   const std::vector<Color>& colors,
                                                   const std::vector<float>& positions = {});

  static std::shared_ptr<Shader> MakeImageShader(std::shared_ptr<Image> image,
                                                TileMode tileModeX = TileMode::Clamp,
                                                TileMode tileModeY = TileMode::Clamp);

  virtual std::shared_ptr<Shader> makeWithMatrix(const Matrix& matrix) const = 0;

 protected:
  Shader() = default;
};

}  // namespace tgfx`,

    'tgfx/core/BlendMode.h': `#pragma once

namespace tgfx {

enum class BlendMode {
  Clear,
  Src,
  Dst,
  SrcOver,
  DstOver,
  SrcIn,
  DstIn,
  SrcOut,
  DstOut,
  SrcATop,
  DstATop,
  Xor,
  Plus,
  Modulate,
  Screen,
  Overlay,
  Darken,
  Lighten,
  ColorDodge,
  ColorBurn,
  HardLight,
  SoftLight,
  Difference,
  Exclusion,
  Multiply,
  Hue,
  Saturation,
  Color,
  Luminosity,
};

}  // namespace tgfx`,

    'tgfx/core/RRect.h': `#pragma once
#include "tgfx/core/Rect.h"

namespace tgfx {

class RRect {
 public:
  RRect() = default;
  RRect(const Rect& rect, float radiusX, float radiusY);
  RRect(const Rect& rect, float radius);

  static RRect MakeRect(const Rect& rect);
  static RRect MakeOval(const Rect& rect);
  static RRect MakeRectXY(const Rect& rect, float radiusX, float radiusY);
  static RRect MakeNinePatch(const Rect& rect, float leftRadius, float topRadius, float rightRadius, float bottomRadius);

  const Rect& rect() const { return fRect; }
  float radiusX() const { return fRadiusX; }
  float radiusY() const { return fRadiusY; }

  bool isRect() const;
  bool isOval() const;
  bool isSimple() const;
  bool isNinePatch() const;

  bool isEmpty() const;

 private:
  Rect fRect;
  float fRadiusX = 0, fRadiusY = 0;
};

}  // namespace tgfx`,

    'tgfx/core/Path.h': `#pragma once
#include "tgfx/core/Point.h"
#include "tgfx/core/Rect.h"

namespace tgfx {

enum class PathFillType {
  Winding,
  EvenOdd,
};

class Path {
 public:
  Path() = default;
  Path(const Path&) = default;
  Path& operator=(const Path&) = default;

  void reset();
  void rewind();

  void moveTo(float x, float y);
  void moveTo(const Point& point);

  void lineTo(float x, float y);
  void lineTo(const Point& point);

  void quadTo(float x1, float y1, float x2, float y2);
  void quadTo(const Point& point1, const Point& point2);

  void cubicTo(float x1, float y1, float x2, float y2, float x3, float y3);
  void cubicTo(const Point& point1, const Point& point2, const Point& point3);

  void close();

  void addRect(const Rect& rect);
  void addOval(const Rect& oval);
  void addCircle(float centerX, float centerY, float radius);
  void addCircle(const Point& center, float radius);

  void transform(const Matrix& matrix);

  Rect getBounds() const;

  bool isEmpty() const;
  bool isLine() const;
  bool isRect() const;
  bool isOval() const;
  bool isCircle() const;

  void setFillType(PathFillType fillType);
  PathFillType getFillType() const;

  void toggleInverseFillType();

 private:
  // Implementation details would go here
};

}  // namespace tgfx`,

    'tgfx/core/Matrix.h': `#pragma once
#include "tgfx/core/Point.h"
#include "tgfx/core/Rect.h"

namespace tgfx {

class Matrix {
 public:
  Matrix() = default;
  Matrix(float scaleX, float skewX, float skewY, float scaleY, float translateX, float translateY);

  static Matrix I();
  static Matrix MakeTrans(float dx, float dy);
  static Matrix MakeScale(float sx, float sy);
  static Matrix MakeScale(float sx, float sy, float px, float py);
  static Matrix MakeRotate(float degrees);
  static Matrix MakeRotate(float degrees, float px, float py);
  static Matrix MakeSkew(float sx, float sy);

  float getScaleX() const;
  float getScaleY() const;
  float getSkewX() const;
  float getSkewY() const;
  float getTranslateX() const;
  float getTranslateY() const;

  void setScaleX(float scaleX);
  void setScaleY(float scaleY);
  void setSkewX(float skewX);
  void setSkewY(float skewY);
  void setTranslateX(float translateX);
  void setTranslateY(float translateY);

  void setTranslate(float dx, float dy);
  void preTranslate(float dx, float dy);
  void postTranslate(float dx, float dy);

  void setScale(float sx, float sy);
  void setScale(float sx, float sy, float px, float py);
  void preScale(float sx, float sy);
  void preScale(float sx, float sy, float px, float py);
  void postScale(float sx, float sy);
  void postScale(float sx, float sy, float px, float py);

  void setRotate(float degrees);
  void setRotate(float degrees, float px, float py);
  void preRotate(float degrees);
  void preRotate(float degrees, float px, float py);
  void postRotate(float degrees);
  void postRotate(float degrees, float px, float py);

  void setSkew(float sx, float sy);
  void preSkew(float sx, float sy);
  void postSkew(float sx, float sy);

  void setConcat(const Matrix& a, const Matrix& b);
  void preConcat(const Matrix& other);
  void postConcat(const Matrix& other);

  bool invert(Matrix* inverse) const;

  Point mapPoint(const Point& point) const;
  Point mapPoint(float x, float y) const;

  Rect mapRect(const Rect& rect) const;

  bool isIdentity() const;
  bool isScaleTranslate() const;

  float getMaxScale() const;

 private:
  float fMat[6] = {1, 0, 0, 1, 0, 0};
};

}  // namespace tgfx`,

    'tgfx/core/Stroke.h': `#pragma once
#include "tgfx/core/Path.h"

namespace tgfx {

enum class StrokeCap {
  Butt,
  Round,
  Square,
};

enum class StrokeJoin {
  Miter,
  Round,
  Bevel,
};

class Stroke {
 public:
  Stroke() = default;
  Stroke(float width);

  void setWidth(float width);
  float getWidth() const;

  void setCap(StrokeCap cap);
  StrokeCap getCap() const;

  void setJoin(StrokeJoin join);
  StrokeJoin getJoin() const;

  void setMiterLimit(float miterLimit);
  float getMiterLimit() const;

  void setResScale(float resScale);
  float getResScale() const;

  std::shared_ptr<Path> applyToPath(const Path& path) const;

 private:
  float width = 1.0f;
  StrokeCap cap = StrokeCap::Butt;
  StrokeJoin join = StrokeJoin::Miter;
  float miterLimit = 4.0f;
  float resScale = 1.0f;
};

}  // namespace tgfx`,

    'tgfx/core/TileMode.h': `#pragma once

namespace tgfx {

enum class TileMode {
  Clamp,
  Repeat,
  Mirror,
  Decal,
};

}  // namespace tgfx`,

    'tgfx/core/FontStyle.h': `#pragma once

namespace tgfx {

enum class FontWeight {
  Invisible = 0,
  Thin = 100,
  ExtraLight = 200,
  Light = 300,
  Normal = 400,
  Medium = 500,
  SemiBold = 600,
  Bold = 700,
  ExtraBold = 800,
  Black = 900,
  ExtraBlack = 1000,
};

enum class FontSlant {
  Upright,
  Italic,
  Oblique,
};

class FontStyle {
 public:
  FontStyle() = default;
  FontStyle(FontWeight weight, FontSlant slant);

  FontWeight weight() const { return fWeight; }
  FontSlant slant() const { return fSlant; }

  void setWeight(FontWeight weight);
  void setSlant(FontSlant slant);

  bool operator==(const FontStyle& other) const;
  bool operator!=(const FontStyle& other) const;

 private:
  FontWeight fWeight = FontWeight::Normal;
  FontSlant fSlant = FontSlant::Upright;
};

}  // namespace tgfx`,

    'tgfx/core/FontMetrics.h': `#pragma once

namespace tgfx {

class FontMetrics {
 public:
  FontMetrics() = default;

  float top = 0;
  float ascent = 0;
  float descent = 0;
  float bottom = 0;
  float leading = 0;
  float xMin = 0;
  float xMax = 0;
  float xHeight = 0;
  float capHeight = 0;
};

}  // namespace tgfx`,

    'tgfx/core/ImageInfo.h': `#pragma once
#include "tgfx/core/ColorType.h"
#include "tgfx/core/AlphaType.h"

namespace tgfx {

class ImageInfo {
 public:
  ImageInfo() = default;
  ImageInfo(int width, int height, ColorType colorType, AlphaType alphaType = AlphaType::Premul);

  static ImageInfo Make(int width, int height, ColorType colorType, AlphaType alphaType = AlphaType::Premul);
  static ImageInfo MakeN32Premul(int width, int height);
  static ImageInfo MakeN32(int width, int height, AlphaType alphaType = AlphaType::Premul);

  int width() const { return fWidth; }
  int height() const { return fHeight; }
  ColorType colorType() const { return fColorType; }
  AlphaType alphaType() const { return fAlphaType; }

  bool isEmpty() const;
  int bytesPerPixel() const;
  size_t minRowBytes() const;

  bool operator==(const ImageInfo& other) const;
  bool operator!=(const ImageInfo& other) const;

 private:
  int fWidth = 0, fHeight = 0;
  ColorType fColorType = ColorType::Unknown;
  AlphaType fAlphaType = AlphaType::Unknown;
};

}  // namespace tgfx`,

    'tgfx/core/Pixmap.h': `#pragma once
#include "tgfx/core/ImageInfo.h"

namespace tgfx {

class Pixmap {
 public:
  Pixmap() = default;
  Pixmap(const ImageInfo& info, void* pixels, size_t rowBytes);

  const ImageInfo& info() const { return fInfo; }
  void* pixels() const { return fPixels; }
  size_t rowBytes() const { return fRowBytes; }

  bool isEmpty() const;
  bool readPixels(const ImageInfo& dstInfo, void* dstPixels, size_t dstRowBytes, int srcX = 0, int srcY = 0) const;

 private:
  ImageInfo fInfo;
  void* fPixels = nullptr;
  size_t fRowBytes = 0;
};

}  // namespace tgfx`,

    'tgfx/core/Image.h': `#pragma once
#include "tgfx/core/ImageInfo.h"
#include "tgfx/core/Pixmap.h"

namespace tgfx {

class Image {
 public:
  virtual ~Image() = default;

  static std::shared_ptr<Image> MakeFromFile(const std::string& path);
  static std::shared_ptr<Image> MakeFromPixmap(const Pixmap& pixmap);

  virtual int width() const = 0;
  virtual int height() const = 0;
  virtual bool isOpaque() const = 0;
  virtual bool isAlphaOnly() const = 0;

  virtual std::shared_ptr<Image> makeRasterImage() const = 0;

  virtual bool readPixels(const ImageInfo& dstInfo, void* dstPixels, size_t dstRowBytes,
                         int srcX = 0, int srcY = 0) const = 0;

  virtual bool readPixels(const Pixmap& dst, int srcX = 0, int srcY = 0) const = 0;
};

}  // namespace tgfx`,

    'tgfx/core/SamplingOptions.h': `#pragma once
#include "tgfx/core/FilterMode.h"
#include "tgfx/core/MipmapMode.h"

namespace tgfx {

class SamplingOptions {
 public:
  SamplingOptions() = default;
  SamplingOptions(FilterMode filter, MipmapMode mipmap = MipmapMode::None);

  FilterMode filter() const { return fFilter; }
  MipmapMode mipmap() const { return fMipmap; }

  void setFilter(FilterMode filter);
  void setMipmap(MipmapMode mipmap);

 private:
  FilterMode fFilter = FilterMode::Linear;
  MipmapMode fMipmap = MipmapMode::None;
};

}  // namespace tgfx`,

    'tgfx/core/FilterMode.h': `#pragma once

namespace tgfx {

enum class FilterMode {
  Nearest,
  Linear,
};

}  // namespace tgfx`,

    'tgfx/core/MipmapMode.h': `#pragma once

namespace tgfx {

enum class MipmapMode {
  None,
  Nearest,
  Linear,
};

}  // namespace tgfx`,

    'tgfx/core/Shape.h': `#pragma once
#include "tgfx/core/Path.h"

namespace tgfx {

enum class ShapeType {
  Path,
  Matrix,
};

class Shape {
 public:
  virtual ~Shape() = default;

  virtual ShapeType type() const = 0;
  virtual bool isSimplePath() const = 0;

  virtual std::shared_ptr<Shape> makeClone() const = 0;
};

class PathShape : public Shape {
 public:
  explicit PathShape(const Path& path);

  ShapeType type() const override { return ShapeType::Path; }
  bool isSimplePath() const override { return true; }

  std::shared_ptr<Shape> makeClone() const override;

  Path path;
};

}  // namespace tgfx`,

    'tgfx/core/TextBlob.h': `#pragma once
#include "tgfx/core/Font.h"
#include "tgfx/core/GlyphRun.h"

namespace tgfx {

class TextBlob {
 public:
  static std::shared_ptr<TextBlob> MakeFrom(const std::string& text, const Font& font);

  virtual ~TextBlob() = default;

  virtual Rect getBounds() const = 0;
  virtual bool getPath(Path* path) const = 0;

  virtual size_t glyphRunCount() const = 0;
  virtual const GlyphRun& getGlyphRun(size_t index) const = 0;
};

}  // namespace tgfx`,

    'tgfx/core/Surface.h': `#pragma once
#include "tgfx/core/Canvas.h"
#include "tgfx/core/ImageInfo.h"
#include "tgfx/core/RenderFlags.h"
#include "tgfx/gpu/Backend.h"
#include "tgfx/gpu/ImageOrigin.h"

namespace tgfx {

class Context;
class RenderTargetProxy;

class Surface {
 public:
  virtual ~Surface() = default;

  static std::shared_ptr<Surface> Make(Context* context, int width, int height,
                                       bool alphaOnly = false, int sampleCount = 1,
                                       bool mipmapped = false, uint32_t renderFlags = 0);

  static std::shared_ptr<Surface> Make(Context* context, int width, int height, ColorType colorType,
                                       int sampleCount = 1, bool mipmapped = false,
                                       uint32_t renderFlags = 0);

  static std::shared_ptr<Surface> MakeFrom(Context* context,
                                           const BackendRenderTarget& renderTarget,
                                           ImageOrigin origin, uint32_t renderFlags = 0);

  static std::shared_ptr<Surface> MakeFrom(Context* context, const BackendTexture& backendTexture,
                                           ImageOrigin origin, int sampleCount = 1,
                                           uint32_t renderFlags = 0);

  static std::shared_ptr<Surface> MakeFrom(Context* context, HardwareBufferRef hardwareBuffer,
                                           int sampleCount = 1, uint32_t renderFlags = 0);

  uint32_t uniqueID() const;
  Context* getContext() const;
  uint32_t renderFlags() const;
  int width() const;
  int height() const;
  ImageOrigin origin() const;
  BackendRenderTarget getBackendRenderTarget();
  BackendTexture getBackendTexture();
  HardwareBufferRef getHardwareBuffer();
  std::shared_ptr<Canvas> getCanvas();
  std::shared_ptr<Image> makeImageSnapshot();
  Color getColor(int x, int y);
  bool readPixels(const ImageInfo& dstInfo, void* dstPixels, int srcX = 0, int srcY = 0);
  static std::shared_ptr<Surface> MakeFrom(std::shared_ptr<RenderTargetProxy> renderTargetProxy,
                                           uint32_t renderFlags = 0, bool clearAll = false);
  bool aboutToDraw(bool discardContent = false);

 private:
  uint32_t _uniqueID = 0;
  Context* _context = nullptr;
  uint32_t _renderFlags = 0;
  int _width = 0;
  int _height = 0;
  ImageOrigin _origin = ImageOrigin::TopLeft;
};

}  // namespace tgfx`,

    'tgfx/gpu/ImageOrigin.h': `#pragma once

namespace tgfx {
/**
 * Textures and render targets can be stored such that (0, 0) in texture space may correspond to
 * either the top-left or bottom-left content pixel.
 */
enum class ImageOrigin {
  /**
   * The default origin of the native coordinate system in the GPU backend. For example, the
   * ImageOrigin::TopLeft is actually the bottom-left origin in the OpenGL coordinate system for
   * textures. Textures newly created by the backend API for off-screen rendering usually have an
   * ImageOrigin::TopLeft origin.
   */
  TopLeft,

  /**
   * Use this origin to flip the content on the y-axis if the GPU backend has a different origin to
   * your system views. It is usually used for on-screen rendering.
   */
  BottomLeft
};
}  // namespace tgfx`,

    'tgfx/gpu/Backend.h': `#pragma once

namespace tgfx {
/**
 * Possible GPU backend APIs that may be used by TGFX.
 */
enum class Backend {
  /**
   * Mock is a backend that does not draw anything. It is used for unit tests and to measure CPU
   * overhead.
   */
  MOCK,
  OPENGL,
  METAL,
  VULKAN,
};

/**
 * Wrapper class for passing into and receiving data from TGFX about a backend texture object.
 */
class BackendTexture {
 public:
  /**
   * Creates an invalid backend texture.
   */
  BackendTexture() : _width(0), _height(0) {
  }

  /**
   * Creates an OpenGL backend texture.
   */
  BackendTexture(const void* glInfo, int width, int height);

  /**
   * Creates a Metal backend texture.
   */
  BackendTexture(const void* mtlInfo, int width, int height);

  BackendTexture(const BackendTexture& that);

  BackendTexture& operator=(const BackendTexture& that);

  /**
   * Returns true if the backend texture has been initialized.
   */
  bool isValid() const {
    return _width > 0 && _height > 0;
  }

  /**
   * Returns the width of the texture.
   */
  int width() const {
    return _width;
  }

  /**
   * Returns the height of the texture.
   */
  int height() const {
    return _height;
  }

  /**
   * Returns the backend API of this texture.
   */
  Backend backend() const {
    return _backend;
  }

  /**
   * If the backend API is GL, copies a snapshot of the GLTextureInfo struct into the passed in
   * pointer and returns true. Otherwise, returns false if the backend API is not GL.
   */
  bool getGLTextureInfo(void* glTextureInfo) const;

  /**
   * If the backend API is Metal, copies a snapshot of the GrMtlTextureInfo struct into the passed
   * in pointer and returns true. Otherwise, returns false if the backend API is not Metal.
   */
  bool getMtlTextureInfo(void* mtlTextureInfo) const;

 private:
  Backend _backend = Backend::MOCK;
  int _width = 0;
  int _height = 0;
  union {
    void* glInfo;
    void* mtlInfo;
  };
};

/**
 * Wrapper class for passing into and receiving data from TGFX about a backend render target object.
 */
class BackendRenderTarget {
 public:
  /**
   * Creates an invalid backend render target.
   */
  BackendRenderTarget() : _width(0), _height(0) {
  }

  /**
   * Creates an OpenGL backend render target.
   */
  BackendRenderTarget(const void* glInfo, int width, int height);

  /**
   * Creates a Metal backend render target.
   */
  BackendRenderTarget(const void* mtlInfo, int width, int height);

  BackendRenderTarget(const BackendRenderTarget& that);

  BackendRenderTarget& operator=(const BackendRenderTarget& that);

  /**
   * Returns true if the backend render target has been initialized.
   */
  bool isValid() const {
    return _width > 0 && _height > 0;
  }

  /**
   * Returns the width of the render target.
   */
  int width() const {
    return _width;
  }

  /**
   * Returns the height of the render target.
   */
  int height() const {
    return _height;
  }

  /**
   * Returns the backend API of this render target.
   */
  Backend backend() const {
    return _backend;
  }

  /**
   * If the backend API is GL, copies a snapshot of the GLFrameBufferInfo struct into the passed in
   * pointer and returns true. Otherwise, returns false if the backend API is not GL.
   */
  bool getGLFrameBufferInfo(void* glFrameBufferInfo) const;

  /**
   * If the backend API is Metal, copies a snapshot of the MtlTextureInfo struct into the passed in
   * pointer and returns true. Otherwise, returns false if the backend API is not Metal.
   */
  bool getMtlTextureInfo(void* mtlTextureInfo) const;

 private:
  Backend _backend = Backend::MOCK;
  int _width = 0;
  int _height = 0;
  union {
    void* glInfo;
    void* mtlInfo;
  };
};

using HardwareBufferRef = void*;

}  // namespace tgfx`,

    'tgfx/core/RenderFlags.h': `#pragma once
#include <cinttypes>

namespace tgfx {
/**
 * Defines flags that can be passed to the rendering process. The tgfx runtime can interpret these
 * to optimize performance, such as by disabling certain expensive features.
 */
class RenderFlags {
 public:
  /**
   * Skips generating any new caches to the associated Context during the rendering process.
   */
  static constexpr uint32_t DisableCache = 1 << 0;

  /**
   * Performs all CPU-side tasks in the current thread rather than run them in parallel
   * asynchronously.
   */
  static constexpr uint32_t DisableAsyncTask = 1 << 1;
};
}  // namespace tgfx`,

    'tgfx/core/GlyphRun.h': `#pragma once
#include "tgfx/core/Font.h"
#include "tgfx/core/Point.h"
#include <vector>

namespace tgfx {

using GlyphID = uint16_t;

class GlyphRun {
 public:
  GlyphRun() = default;
  GlyphRun(const Font& font, const std::vector<GlyphID>& glyphs, const std::vector<Point>& positions);

  const Font& getFont() const { return font; }
  const std::vector<GlyphID>& getGlyphs() const { return glyphs; }
  const std::vector<Point>& getPositions() const { return positions; }

 private:
  Font font;
  std::vector<GlyphID> glyphs;
  std::vector<Point> positions;
};

}  // namespace tgfx`,

    'tgfx/core/Picture.h': `#pragma once
#include "tgfx/core/Canvas.h"

namespace tgfx {

class Picture {
 public:
  virtual ~Picture() = default;

  virtual void draw(Canvas* canvas) const = 0;

  virtual int width() const = 0;
  virtual int height() const = 0;
};

}  // namespace tgfx`,

    'tgfx/core/ColorFilter.h': `#pragma once
#include "tgfx/core/Color.h"

namespace tgfx {

class ColorFilter {
 public:
  virtual ~ColorFilter() = default;

  virtual Color filterColor(const Color& color) const = 0;

  virtual std::shared_ptr<ColorFilter> makeClone() const = 0;
};

}  // namespace tgfx`,

    'tgfx/core/ImageFilter.h': `#pragma once
#include "tgfx/core/Color.h"
#include "tgfx/core/Image.h"

namespace tgfx {

class ImageFilter {
 public:
  virtual ~ImageFilter() = default;

  static std::shared_ptr<ImageFilter> DropShadow(float dx, float dy, float sigma, float radius, const Color& color);

  virtual std::shared_ptr<Image> filterImage(std::shared_ptr<Image> image) const = 0;

  virtual std::shared_ptr<ImageFilter> makeClone() const = 0;
};

}  // namespace tgfx`,

    'tgfx/core/MaskFilter.h': `#pragma once
#include "tgfx/core/Shader.h"

namespace tgfx {

class MaskFilter {
 public:
  virtual ~MaskFilter() = default;

  static std::shared_ptr<MaskFilter> MakeShader(std::shared_ptr<Shader> shader);

  virtual std::shared_ptr<MaskFilter> makeWithMatrix(const Matrix& matrix) const = 0;

  virtual std::shared_ptr<MaskFilter> makeClone() const = 0;
};

}  // namespace tgfx`,

    'tgfx/core/Fill.h': `#pragma once
#include "tgfx/core/BlendMode.h"
#include "tgfx/core/Color.h"
#include "tgfx/core/Shader.h"

namespace tgfx {

class Fill {
 public:
  Fill() = default;
  Fill(const Color& color, BlendMode blendMode = BlendMode::SrcOver);
  Fill(std::shared_ptr<Shader> shader, BlendMode blendMode = BlendMode::SrcOver);

  Color color;
  std::shared_ptr<Shader> shader;
  BlendMode blendMode = BlendMode::SrcOver;

  Fill makeWithMatrix(const Matrix& matrix) const;
};

}  // namespace tgfx`
};

// DOM å…ƒç´ 
const compileBtn = document.getElementById('compileBtn');
const loadingIcon = document.getElementById('loadingIcon');
const compileText = document.getElementById('compileText');
const codeEditor = document.getElementById('codeEditor');
const statusIndicator = document.getElementById('statusIndicator');
const compilerStatus = document.getElementById('compilerStatus');
const tgfxLibInfo = document.getElementById('tgfxLibInfo');
const libraryStatus = document.getElementById('libraryStatus');
const consoleArea = document.getElementById('consoleArea');

// è®¾ç½®çŠ¶æ€æŒ‡ç¤ºå™¨
function setStatus(message, type = 'info') {
    statusIndicator.textContent = message;
    statusIndicator.className = `status-indicator status-${type}`;
}

// è®¾ç½®ç¼–è¯‘å™¨çŠ¶æ€
function setCompilerStatus(status) {
    compilerStatus.textContent = status;
}

// è®¾ç½®TGFXåº“ä¿¡æ¯
function setTGFXLibInfo(info) {
    tgfxLibInfo.textContent = info;
}

// æ·»åŠ æ§åˆ¶å°è¾“å‡º
function addConsoleOutput(message, type = 'info') {
    const line = document.createElement('div');
    line.className = `console-line console-${type}`;
    line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    consoleArea.appendChild(line);
    consoleArea.scrollTop = consoleArea.scrollHeight;
}

// é‡å®šå‘æ§åˆ¶å°è¾“å‡ºä»¥æ•è· clang.js çš„è¾“å‡º
function setupConsoleCapture() {
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;

    // è¿‡æ»¤æ‰ä¸€äº›å¸¸è§çš„WebGLè­¦å‘Šä¿¡æ¯
    const webglWarnings = [
        'WebGLDevice::MakeFrom emscripten_webgl_create_context error',
        'WebGL context creation failed',
        'WebGL not supported'
    ];

    console.log = function(...args) {
        originalLog.apply(console, args);
        const message = args.join(' ');
        if (message.trim()) {
            // è¿‡æ»¤clangç¼–è¯‘å™¨çš„è¯¦ç»†è¾“å‡º
            const isClangOutput = message.includes('clang -cc1') ||
                                message.includes('[0m') ||
                                message.includes('[1m') ||
                                message.includes('[7m') ||
                                message.includes(':[0m') ||
                                message.includes('error:') ||
                                message.includes('warning:') ||
                                message.includes('null character ignored') ||
                                message.includes('source file is not valid UTF-8') ||
                                message.includes('unknown type name') ||
                                message.includes('expected unqualified-id') ||
                                message.includes('UTF-8') ||
                                message.includes('<F4>') ||
                                message.includes('<U+') ||
                                message.includes('<CB>') ||
                                message.includes('===') ||
                                /^\d+$/.test(message.trim()) ||  // çº¯æ•°å­—è¡Œ
                                message.includes('generated.') ||
                                message.includes('.cc:') ||
                                message.includes('^') ||
                                /^[a-zA-Z]+$/.test(message.trim()) ||  // å•è¯è¡Œ
                                message.length < 3;  // å¾ˆçŸ­çš„ç‰‡æ®µ

            if (!isClangOutput) {
                addConsoleOutput(message, 'success');
            }
        }
    };

    console.error = function(...args) {
        originalError.apply(console, args);
        const message = args.join(' ');
        if (message.trim()) {
            // è¿‡æ»¤æ‰WebGLç›¸å…³çš„é”™è¯¯ä¿¡æ¯å’Œclangè¯¦ç»†è¾“å‡º
            const isWebGLError = webglWarnings.some(warning => message.includes(warning));
            const isClangOutput = message.includes('clang -cc1') ||
                                message.includes('[0m') ||
                                message.includes('[1m') ||
                                message.includes('[7m') ||
                                message.includes(':[0m') ||
                                message.includes('null character ignored') ||
                                message.includes('source file is not valid UTF-8') ||
                                message.includes('unknown type name') ||
                                message.includes('expected unqualified-id') ||
                                message.includes('UTF-8') ||
                                message.includes('<F4>') ||
                                message.includes('<U+') ||
                                message.includes('<CB>') ||
                                message.includes('===') ||
                                /^\d+$/.test(message.trim()) ||
                                message.includes('generated.') ||
                                message.includes('.cc:') ||
                                message.includes('^') ||
                                /^[a-zA-Z]+$/.test(message.trim()) ||
                                message.length < 3;

            if (!isWebGLError && !isClangOutput) {
                addConsoleOutput(message, 'error');
            }
        }
    };

    console.warn = function(...args) {
        originalWarn.apply(console, args);
        const message = args.join(' ');
        if (message.trim()) {
            // è¿‡æ»¤æ‰WebGLç›¸å…³çš„è­¦å‘Šä¿¡æ¯å’Œclangè¯¦ç»†è¾“å‡º
            const isWebGLWarning = webglWarnings.some(warning => message.includes(warning));
            const isClangOutput = message.includes('clang -cc1') ||
                                message.includes('[0m') ||
                                message.includes('[1m') ||
                                message.includes('[7m') ||
                                message.includes(':[0m') ||
                                message.includes('null character ignored') ||
                                message.includes('source file is not valid UTF-8') ||
                                message.includes('unknown type name') ||
                                message.includes('expected unqualified-id') ||
                                message.includes('UTF-8') ||
                                message.includes('<F4>') ||
                                message.includes('<U+') ||
                                message.includes('<CB>') ||
                                message.includes('===') ||
                                /^\d+$/.test(message.trim()) ||
                                message.includes('generated.') ||
                                message.includes('.cc:') ||
                                message.includes('^') ||
                                /^[a-zA-Z]+$/.test(message.trim()) ||
                                message.length < 3;

            if (!isWebGLWarning && !isClangOutput) {
                addConsoleOutput(message, 'warning');
            }
        }
    };
}

// æ¸…ç©ºæ§åˆ¶å°
function clearConsole() {
    const fixedLines = [
        'ğŸš€ TGFX å…¨é‡å†…è”ç¼–è¯‘å™¨æ§åˆ¶å°',
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”'
    ];
    
    consoleArea.innerHTML = '';
    fixedLines.forEach(line => {
        const div = document.createElement('div');
        div.className = 'console-line console-info';
        div.textContent = line;
        consoleArea.appendChild(div);
    });
    
    addConsoleOutput('æ§åˆ¶å°å·²æ¸…ç©º', 'info');
}

// åˆå§‹åŒ– clang.js ç¼–è¯‘å™¨
async function initClang() {
    try {
        addConsoleOutput('ğŸš€ åˆå§‹åŒ–ç¼–è¯‘å™¨...', 'compile');

        try {
        // åˆå§‹åŒ–clang.js
        await init({
            path: 'https://cdn.jsdelivr.net/npm/clang.js@0.1.0/dist'
        });
        
        addConsoleOutput('âœ… ç¼–è¯‘å™¨åˆå§‹åŒ–å®Œæˆ', 'success');

        // ç­‰å¾…åˆå§‹åŒ–å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 1000));

        // é…ç½®ç¼–è¯‘å™¨API
        clangAPI = {
            run: run,
            init: init,
            worker: null
        };

        // å…¨é‡å†…è”å¤´æ–‡ä»¶ç³»ç»Ÿå·²å°±ç»ª
        addConsoleOutput('âœ… TGFXå…¨é‡å†…è”å¤´æ–‡ä»¶ç³»ç»Ÿå°±ç»ª', 'success');
        
        return true;
        } catch (initError) {
            addConsoleOutput('âŒ clang.js åˆå§‹åŒ–å¤±è´¥: ' + initError.message, 'error');
            addConsoleOutput('é”™è¯¯è¯¦æƒ…: ' + initError.stack, 'error');
            clangAPI = false;
            return false;
        }
    } catch (error) {
        addConsoleOutput('âŒ clang.js åˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');
        addConsoleOutput('é”™è¯¯è¯¦æƒ…: ' + error.stack, 'error');
        clangAPI = undefined; // ç¡®ä¿clangAPIè¢«é‡ç½®
        return false;
    }
}

        // æ·»åŠ æ›´å®Œå–„çš„é”™è¯¯å¤„ç†
        function handleClangError(error) {
            console.error('Clang.js é”™è¯¯:', error);
            addConsoleOutput(`âš ï¸ ç¼–è¯‘å™¨é”™è¯¯: ${error.message}`, 'error');
            
            // æ˜¾ç¤ºæ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
            if (error.message.includes('memory')) {
                addConsoleOutput('æç¤º: å°è¯•å‡å°‘ä»£ç å¤æ‚åº¦æˆ–å†…å­˜ä½¿ç”¨', 'warning');
            } else if (error.message.includes('timeout')) {
                addConsoleOutput('æç¤º: å¤æ‚ä»£ç å¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´ç¼–è¯‘', 'warning');
            }
            
            updateStatus('error');
        }
        
        // æ›´æ–°çŠ¶æ€ç®¡ç†å‡½æ•°
        function updateStatus(status) {
            const statusEl = document.getElementById('compilerStatus');
            statusEl.className = `status-indicator status-${status}`;
            
            switch(status) {
                case 'ready':
                    statusEl.textContent = 'å°±ç»ª';
                    break;
                case 'compiling':
                    statusEl.textContent = 'ç¼–è¯‘ä¸­...';
                    break;
                case 'error':
                    statusEl.textContent = 'é”™è¯¯';
                    break;
                case 'success':
                    statusEl.textContent = 'æˆåŠŸ';
                    break;
            }
            
            // æ§åˆ¶æŒ‰é’®çŠ¶æ€
            const compileBtn = document.getElementById('compileBtn');
            compileBtn.disabled = status === 'compiling';
        }

// åˆå§‹åŒ–TGFXæ¨¡å—ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œä»…ç”¨äºWebGLä¸Šä¸‹æ–‡æ£€æŸ¥ï¼‰
async function initTGFX() {
    try {
        addConsoleOutput('æ­£åœ¨æ£€æŸ¥WebGLæ”¯æŒ...', 'info');
        
        // åˆ›å»ºWebGLä¸Šä¸‹æ–‡ï¼Œä½¿ç”¨æ›´å¥½çš„é…ç½®
        renderCanvas = document.getElementById('renderCanvas');

        // å°è¯•åˆ›å»ºWebGL2ä¸Šä¸‹æ–‡
        const webgl2Options = {
            alpha: true,
            antialias: true,
            depth: false,
            failIfMajorPerformanceCaveat: false,
            powerPreference: 'default',
            premultipliedAlpha: true,
            preserveDrawingBuffer: false,
            stencil: false
        };

        glContext = renderCanvas.getContext('webgl2', webgl2Options);

        if (!glContext) {
            // å¦‚æœWebGL2ä¸å¯ç”¨ï¼Œå°è¯•WebGL1
            const webgl1Options = {
                alpha: true,
                antialias: true,
                depth: false,
                failIfMajorPerformanceCaveat: false,
                powerPreference: 'default',
                premultipliedAlpha: true,
                preserveDrawingBuffer: false,
                stencil: false
            };

            glContext = renderCanvas.getContext('webgl', webgl1Options) ||
                       renderCanvas.getContext('experimental-webgl', webgl1Options);
        }

        if (!glContext) {
            addConsoleOutput('âŒ WebGLä¸å¯ç”¨ï¼ŒTGFXæ¨¡å¼éœ€è¦WebGLæ”¯æŒ', 'error');
            tgfxLibraryLoaded = false;
            throw new Error('WebGLä¸å¯ç”¨ï¼Œæ— æ³•åˆå§‹åŒ–TGFXæ¨¡å¼');
        }

        addConsoleOutput('âœ… WebGLæ”¯æŒæ­£å¸¸', 'success');

        tgfxLibraryLoaded = true;
        
    } catch (error) {
        addConsoleOutput('âŒ WebGLåˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');
        addConsoleOutput('âŒ TGFXæ¨¡å¼éœ€è¦WebGLæ”¯æŒ', 'error');
        tgfxLibraryLoaded = false;
        throw error; // é‡æ–°æŠ›å‡ºé”™è¯¯ï¼Œè®©ä¸Šå±‚å¤„ç†
    }
}

// ç›´æ¥ä½¿ç”¨çœŸå®çš„TGFX WASMæ¸²æŸ“
function exposeTGFXFunctions() {
    if (tgfxView) {
        // æš´éœ²çœŸå®çš„TGFX APIç»™C++ä»£ç 
        window.tgfxView = tgfxView;
        addConsoleOutput('âœ… TGFX APIå·²å°±ç»ª', 'success');
    }
}

// å°è¯•åˆå§‹åŒ–Hello2Dæ¨¡å—ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
async function initHello2D() {
    try {
        addConsoleOutput('å°è¯•åŠ è½½Hello2Dæ¨¡å—...', 'info');

        // æ·»åŠ è¶…æ—¶å¤„ç†ï¼ˆå¢åŠ åˆ°90ç§’ï¼Œç»™WASMæ›´å¤šåŠ è½½æ—¶é—´ï¼‰
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Hello2Dæ¨¡å—åŠ è½½è¶…æ—¶')), 90000); // 90ç§’è¶…æ—¶
        });

        // ä½¿ç”¨ä¸æ ‡å‡†demoç›¸åŒçš„è·¯å¾„
        addConsoleOutput('æ­£åœ¨å¯¼å…¥Hello2D JavaScriptæ¨¡å—...', 'info');
        const Hello2D = await Promise.race([
            import('./wasm-mt/hello2d.js'),
            timeoutPromise
        ]);
        
        addConsoleOutput('æ­£åœ¨åˆå§‹åŒ–Hello2D WASMæ¨¡å—...', 'info');
        Hello2DModule = await Promise.race([
            Hello2D.default({
                locateFile: (file) => {
                    addConsoleOutput(`å®šä½æ–‡ä»¶: ${file}`, 'info');
                    return './wasm-mt/' + file;
                },
                mainScriptUrlOrBlob: './wasm-mt/hello2d.js',
                onRuntimeInitialized: () => {
                    addConsoleOutput('WASMè¿è¡Œæ—¶åˆå§‹åŒ–å®Œæˆ', 'info');
                },
                print: (text) => {
                    addConsoleOutput(`[WASM] ${text}`, 'info');
                },
                printErr: (text) => {
                    addConsoleOutput(`[WASMé”™è¯¯] ${text}`, 'error');
                },
                onAbort: (what) => {
                    addConsoleOutput(`[WASMä¸­æ­¢] ${what}`, 'error');
                },
                // ç¦ç”¨ä¸€äº›å¯èƒ½å¯¼è‡´é—®é¢˜çš„ç‰¹æ€§
                noInitialRun: false,
                noExitRuntime: true,
                // å¢åŠ å†…å­˜é™åˆ¶
                INITIAL_MEMORY: 64 * 1024 * 1024, // 64MB
                MAXIMUM_MEMORY: 128 * 1024 * 1024, // 128MB
                // å¯ç”¨å¤šçº¿ç¨‹æ”¯æŒ
                PTHREAD_POOL_SIZE: 4
            }),
            timeoutPromise
        ]);

        addConsoleOutput('Hello2Dæ¨¡å—åˆå§‹åŒ–å®Œæˆï¼Œæ£€æŸ¥ç»‘å®š...', 'info');
        
        // è¯¦ç»†è°ƒè¯•Hello2Dæ¨¡å—
        addConsoleOutput('ğŸ” Hello2Dæ¨¡å—è¯¦ç»†ä¿¡æ¯:', 'info');
        addConsoleOutput('Hello2DModuleå­˜åœ¨: ' + !!Hello2DModule, 'info');
        addConsoleOutput('Hello2DModuleç±»å‹: ' + typeof Hello2DModule, 'info');
        
        if (Hello2DModule) {
            const keys = Object.keys(Hello2DModule);
            addConsoleOutput('Hello2DModuleé”®æ•°é‡: ' + keys.length, 'info');
            addConsoleOutput('Hello2DModuleå‰10ä¸ªé”®: ' + keys.slice(0, 10).join(', '), 'info');
            
            addConsoleOutput('TGFXThreadsViewå­˜åœ¨: ' + !!Hello2DModule.TGFXThreadsView, 'info');
            if (Hello2DModule.TGFXThreadsView) {
                addConsoleOutput('TGFXThreadsViewç±»å‹: ' + typeof Hello2DModule.TGFXThreadsView, 'info');
                const methods = Object.getOwnPropertyNames(Hello2DModule.TGFXThreadsView);
                addConsoleOutput('TGFXThreadsViewæ–¹æ³•: ' + methods.join(', '), 'info');
            }
        }

        // ä½¿ç”¨ä¸æ ‡å‡†demoç›¸åŒçš„ç»‘å®šæ–¹å¼
        if (typeof window.TGFXBind === 'function') {
            window.TGFXBind(Hello2DModule);
            addConsoleOutput('TGFXBindç»‘å®šå®Œæˆ', 'info');
        } else {
            addConsoleOutput('âš ï¸ window.TGFXBindä¸å¯ç”¨', 'warning');
        }

        if (!Hello2DModule || !Hello2DModule.TGFXThreadsView) {
            addConsoleOutput('âŒ å…³é”®æ£€æŸ¥å¤±è´¥:', 'error');
            addConsoleOutput('Hello2DModule: ' + !!Hello2DModule, 'error');
            addConsoleOutput('TGFXThreadsView: ' + !!(Hello2DModule && Hello2DModule.TGFXThreadsView), 'error');
            throw new Error('Hello2Dæ¨¡å—åŠ è½½å¤±è´¥æˆ–TGFXThreadsViewä¸å¯ç”¨');
        }

        // åˆ›å»ºTGFXè§†å›¾
        try {
            addConsoleOutput('æ­£åœ¨åˆ›å»ºTGFXè§†å›¾...', 'info');
            addConsoleOutput('ğŸ” è°ƒè¯•Hello2DModule...', 'info');
            addConsoleOutput('Hello2DModuleç±»å‹: ' + typeof Hello2DModule, 'info');
            addConsoleOutput('Hello2DModuleé”®: ' + Object.keys(Hello2DModule).join(', '), 'info');
            
            if (Hello2DModule.TGFXThreadsView) {
                addConsoleOutput('TGFXThreadsViewå¯ç”¨', 'info');
                addConsoleOutput('TGFXThreadsViewæ–¹æ³•: ' + Object.getOwnPropertyNames(Hello2DModule.TGFXThreadsView).join(', '), 'info');
            }
            
            tgfxView = Hello2DModule.TGFXThreadsView.MakeFrom('#renderCanvas');
            
            addConsoleOutput('ğŸ” è°ƒè¯•tgfxView...', 'info');
            addConsoleOutput('tgfxViewç±»å‹: ' + typeof tgfxView, 'info');
            addConsoleOutput('tgfxViewæ˜¯å¦ä¸ºnull: ' + (tgfxView === null), 'info');
            
            if (tgfxView) {
                addConsoleOutput('tgfxViewæ„é€ å‡½æ•°: ' + (tgfxView.constructor ? tgfxView.constructor.name : 'unknown'), 'info');
                
                // åˆ—å‡ºæ‰€æœ‰å±æ€§å’Œæ–¹æ³•
                const props = [];
                const methods = [];
                for (let prop in tgfxView) {
                    if (typeof tgfxView[prop] === 'function') {
                        methods.push(prop);
                    } else {
                        props.push(prop);
                    }
                }
                addConsoleOutput('tgfxViewå±æ€§: ' + props.join(', '), 'info');
                addConsoleOutput('tgfxViewæ–¹æ³•: ' + methods.join(', '), 'info');
                
                // å°è¯•è°ƒç”¨æ‰€æœ‰å¯èƒ½çš„æ¸²æŸ“æ–¹æ³•
                const possibleMethods = ['draw', 'render', 'paint', 'flush', 'present', 'update', 'refresh'];
                for (const method of possibleMethods) {
                    if (typeof tgfxView[method] === 'function') {
                        addConsoleOutput(`âœ… æ‰¾åˆ°æ¸²æŸ“æ–¹æ³•: ${method}`, 'success');
                        try {
                            // å°è¯•ä¸åŒå‚æ•°
                            const results = [
                                tgfxView[method](),
                                tgfxView[method](0),
                                tgfxView[method](1),
                                tgfxView[method](0, 1.0),
                                tgfxView[method](1, 1.0, 0, 0)
                            ];
                            addConsoleOutput(`${method} è°ƒç”¨ç»“æœ: ${results.join(', ')}`, 'info');
                        } catch (e) {
                            addConsoleOutput(`${method} è°ƒç”¨å¤±è´¥: ${e.message}`, 'warning');
                        }
                    }
                }
                
                addConsoleOutput('TGFXè§†å›¾åˆ›å»ºæˆåŠŸï¼ŒåŠ è½½èµ„æº...', 'info');
                
                // åŠ è½½èµ„æºï¼ˆä¸æ ‡å‡†demoä¸€è‡´ï¼‰
                try {
                    await loadTGFXResources();
                } catch (resourceError) {
                    addConsoleOutput('âš ï¸ èµ„æºåŠ è½½å¤±è´¥ï¼Œä½†ç»§ç»­åˆå§‹åŒ–: ' + resourceError.message, 'warning');
                }

                updateCanvasSize();
                // ä¸è¦è‡ªåŠ¨ç»˜åˆ¶ç¤ºä¾‹ï¼Œç­‰å¾…ç”¨æˆ·ä»£ç 
                // drawWithTGFX(0);
                isRealTGFX = true;
                setTGFXLibInfo('TGFXåº“: å·²åŠ è½½');
                addConsoleOutput('âœ… Hello2Dæ¨¡å—åŠ è½½æˆåŠŸ', 'success');
            } else {
                addConsoleOutput('âŒ tgfxViewåˆ›å»ºå¤±è´¥', 'error');
                throw new Error('tgfxViewåˆ›å»ºå¤±è´¥');
            }
        } catch (tgfxError) {
            addConsoleOutput('âŒ TGFXè§†å›¾åˆ›å»ºå¤±è´¥: ' + tgfxError.message, 'error');
            addConsoleOutput('âŒ æ— æ³•åˆå§‹åŒ–TGFXæ¸²æŸ“æ¨¡å¼', 'error');
            isRealTGFX = false;
            tgfxView = null;
            throw tgfxError; // é‡æ–°æŠ›å‡ºé”™è¯¯
        }

    } catch (error) {
        addConsoleOutput('âŒ Hello2Dæ¨¡å—åŠ è½½å¤±è´¥: ' + error.message, 'error');
        isRealTGFX = false;
        tgfxView = null;
        throw error; // é‡æ–°æŠ›å‡ºé”™è¯¯ä»¥ä¾¿ä¸Šå±‚å¤„ç†
    }
}

// åŠ è½½TGFXèµ„æºï¼ˆä¸æ ‡å‡†demoä¸€è‡´ï¼‰
async function loadTGFXResources() {
    try {
        addConsoleOutput('å¼€å§‹åŠ è½½TGFXèµ„æº...', 'info');
        
        // å°è¯•åŠ è½½å›¾ç‰‡ï¼ˆå¯é€‰ï¼‰
        try {
            const imagePath = "../resources/assets/bridge.jpg";
            if (tgfxView.setImagePath) {
                await tgfxView.setImagePath(imagePath);
                addConsoleOutput('âœ… TGFXå›¾ç‰‡èµ„æºåŠ è½½æˆåŠŸ', 'success');
            }
        } catch (imageError) {
            addConsoleOutput('âš ï¸ å›¾ç‰‡èµ„æºåŠ è½½å¤±è´¥ï¼Œè·³è¿‡: ' + imageError.message, 'warning');
        }

        // å°è¯•åŠ è½½å­—ä½“ï¼ˆå¯é€‰ï¼‰
        try {
            const fontPath = "../resources/font/NotoSansSC-Regular.otf";
            const emojiFontPath = "../resources/font/NotoColorEmoji.ttf";
            
            const fontResponse = await Promise.race([
                fetch(fontPath),
                new Promise((_, reject) => setTimeout(() => reject(new Error('å­—ä½“åŠ è½½è¶…æ—¶')), 5000))
            ]);
            
            if (fontResponse.ok) {
                const fontBuffer = await fontResponse.arrayBuffer();
                const fontUIntArray = new Uint8Array(fontBuffer);

                const emojiFontResponse = await Promise.race([
                    fetch(emojiFontPath),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Emojiå­—ä½“åŠ è½½è¶…æ—¶')), 5000))
                ]);
                
                if (emojiFontResponse.ok) {
                    const emojiFontBuffer = await emojiFontResponse.arrayBuffer();
                    const emojiFontUIntArray = new Uint8Array(emojiFontBuffer);

                    if (tgfxView.registerFonts) {
                        tgfxView.registerFonts(fontUIntArray, emojiFontUIntArray);
                        addConsoleOutput('âœ… TGFXå­—ä½“èµ„æºåŠ è½½æˆåŠŸ', 'success');
                    }
                } else {
                    addConsoleOutput('âš ï¸ Emojiå­—ä½“ä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤å­—ä½“', 'warning');
                }
            } else {
                addConsoleOutput('âš ï¸ ä¸»å­—ä½“ä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤å­—ä½“', 'warning');
            }
        } catch (fontError) {
            addConsoleOutput('âš ï¸ å­—ä½“èµ„æºåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å­—ä½“: ' + fontError.message, 'warning');
        }

        addConsoleOutput('TGFXèµ„æºåŠ è½½å®Œæˆï¼ˆå¯é€‰èµ„æºå·²å°è¯•åŠ è½½ï¼‰', 'info');

    } catch (error) {
        addConsoleOutput('âš ï¸ TGFXèµ„æºåŠ è½½è¿‡ç¨‹å‡ºé”™: ' + error.message, 'warning');
        // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå…è®¸ç»§ç»­åˆå§‹åŒ–
    }
}

// é¢„å¤„ç†C++ä»£ç ï¼Œç§»é™¤emscriptenç›¸å…³å¤´æ–‡ä»¶
function preprocessCppCode(code) {
    let processedCode = code;

    // ç§»é™¤emscriptenç›¸å…³å¤´æ–‡ä»¶
    processedCode = processedCode.replace(/#include\s*<emscripten\/bind\.h>/g, '// emscripten/bind.h removed for clang.js compatibility');
    processedCode = processedCode.replace(/#include\s*<emscripten\/val\.h>/g, '// emscripten/val.h removed for clang.js compatibility');
    processedCode = processedCode.replace(/#include\s*<emscripten\/emscripten\.h>/g, '// emscripten/emscripten.h removed for clang.js compatibility');

    // ä¿ç•™extern "C"å£°æ˜ï¼Œä½†æ·»åŠ æ³¨é‡Šè¯´æ˜è¿™æ˜¯JavaScriptå®ç°
    processedCode = processedCode.replace(/extern "C" \{/g, '// JavaScript implementation of TGFX functions:\nextern "C" {');

    // æ·»åŠ ä¸€äº›å¸¸ç”¨çš„æ•°å­¦å¸¸é‡å®šä¹‰
    if (processedCode.includes('M_PI') && !processedCode.includes('#define M_PI')) {
        processedCode = '#define M_PI 3.14159265358979323846\n' + processedCode;
    }

    // æ›¿æ¢ä¸­æ–‡å­—ç¬¦ä¸ºè‹±æ–‡ï¼Œé¿å…ç¼–ç é—®é¢˜
    processedCode = processedCode.replace(/=== TGFX åœ¨çº¿ç¼–è¯‘å™¨ç¤ºä¾‹ ===/g, '=== TGFX Online Compiler Example ===');
    processedCode = processedCode.replace(/=== TGFX åŸºç¡€ç¤ºä¾‹ ===/g, '=== TGFX Basic Example ===');
    processedCode = processedCode.replace(/=== TGFX é«˜çº§ç¤ºä¾‹ ===/g, '=== TGFX Advanced Example ===');
    processedCode = processedCode.replace(/ç»˜åˆ¶å®Œæˆ!/g, 'Drawing completed!');
    processedCode = processedCode.replace(/é«˜çº§ç»˜åˆ¶å®Œæˆ!/g, 'Advanced drawing completed!');
    processedCode = processedCode.replace(/ç»˜åˆ¶çŸ©å½¢:/g, 'Draw rectangle:');
    processedCode = processedCode.replace(/ç»˜åˆ¶åœ†å½¢:/g, 'Draw circle:');
    processedCode = processedCode.replace(/ç»˜åˆ¶çº¿æ¡:/g, 'Draw line:');
    processedCode = processedCode.replace(/æ¸…ç©ºç”»å¸ƒ:/g, 'Clear canvas:');
    processedCode = processedCode.replace(/ç”»å¸ƒåˆ·æ–°å®Œæˆ/g, 'Canvas flush completed');

    return processedCode;
}

// è§£æTGFX APIè°ƒç”¨ï¼ˆæŒ‰ä»£ç å‡ºç°é¡ºåºï¼‰
function parseTGFXCalls(cppCode) {
    const calls = [];

    // æ‰€æœ‰éœ€è¦åŒ¹é…çš„æ¨¡å¼
    const patterns = [
        { pattern: /canvas->clear\s*\(\s*(?:tgfx::)?Color::([A-Za-z_]+)\s*\(\s*\)\s*\)/g, type: 'clear' },
        { pattern: /canvas->clear\s*\(\s*(?:tgfx::)?Color::([A-Z_]+)\s*\)/g, type: 'clear' },
        { pattern: /(?:tgfx::)?Paint\s+paint/g, type: 'createPaint' },
        { pattern: /paint\.setColor\s*\(\s*(?:tgfx::)?Color::([A-Za-z_]+)\s*\(\s*\)\s*\)/g, type: 'setColor' },
        { pattern: /paint\.setColor\s*\(\s*(?:tgfx::)?Color::([A-Z_]+)\s*\)/g, type: 'setColor' },
        { pattern: /canvas->drawRect\s*\(\s*(?:tgfx::)?Rect::MakeXYWH\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*,\s*paint\s*\)/g, type: 'drawRect' },
        { pattern: /canvas->drawRect\s*\(\s*rect\s*,\s*paint\s*\)/g, type: 'drawRect' },
        { pattern: /canvas->save\s*\(\s*\)/g, type: 'save' },
        { pattern: /canvas->restore\s*\(\s*\)/g, type: 'restore' },
    ];

    // æ‰¾åˆ°æ‰€æœ‰åŒ¹é…é¡¹åŠå…¶ä½ç½®
    const allMatches = [];

    patterns.forEach(patternObj => {
        let match;
        patternObj.pattern.lastIndex = 0; // é‡ç½®regex
        while ((match = patternObj.pattern.exec(cppCode)) !== null) {
            allMatches.push({
                type: patternObj.type,
                match: match,
                fullMatch: match[0],
                position: match.index
            });
        }
    });

    // æŒ‰ç…§åœ¨ä»£ç ä¸­å‡ºç°çš„ä½ç½®æ’åº
    allMatches.sort((a, b) => a.position - b.position);

    return allMatches;
}

// å°†C++ä»£ç è½¬æ¢ä¸ºJavaScriptæ‰§è¡Œ
async function executeCppAsJavaScript(cppCode) {

    // ç®€å•çš„C++ä»£ç è§£æå’ŒJavaScriptæ‰§è¡Œ
    // è¿™é‡Œæˆ‘ä»¬å®ç°ä¸€ä¸ªåŸºæœ¬çš„è§£æå™¨æ¥æ‰§è¡Œmainå‡½æ•°ä¸­çš„TGFXè°ƒç”¨

    // æ£€æŸ¥æ˜¯å¦åŒ…å«mainå‡½æ•°
    if (!cppCode.includes('int main()')) {
        addConsoleOutput('æœªæ‰¾åˆ°mainå‡½æ•°', 'warning');
        return;
    }

    // æå–mainå‡½æ•°ä½“
    const mainMatch = cppCode.match(/int main\(\)\s*\{([\s\S]*?)\}/);
    if (!mainMatch) {
        addConsoleOutput('æ— æ³•è§£æmainå‡½æ•°ä½“', 'warning');
        return;
        }

    const mainBody = mainMatch[1];

    // æ‰§è¡Œstd::coutè¾“å‡º
    const coutMatches = mainBody.match(/std::cout\s*<<\s*"([^"]*)"\s*<<\s*std::endl/g);
    if (coutMatches) {
        coutMatches.forEach(match => {
            const message = match.match(/std::cout\s*<<\s*"([^"]*)"\s*<<\s*std::endl/)[1];
            addConsoleOutput(`[C++] ${message}`, 'success');
        });
}

    // æ‰§è¡ŒçœŸæ­£çš„TGFXåŸç”ŸAPIä»£ç 
    try {
        if (tgfxView && tgfxView.draw) {
            // ç¡®ä¿canvaså¯è§
            if (renderCanvas) {
                renderCanvas.style.border = '2px solid red';
            }

            // è§£æç”¨æˆ·C++ä»£ç ä¸­çš„TGFX APIè°ƒç”¨
            const tgfxCalls = parseTGFXCalls(mainBody);
            addConsoleOutput(`ğŸ¨ æ£€æµ‹åˆ° ${tgfxCalls.length} ä¸ªTGFX APIè°ƒç”¨`, 'info');

            if (tgfxCalls.length > 0) {
                // æ‰§è¡Œç”¨æˆ·çš„TGFXä»£ç é€»è¾‘
                addConsoleOutput('ğŸ¯ é€šè¿‡çœŸå®TGFXæ‰§è¡Œç”¨æˆ·ä»£ç ...', 'info');
                
                // æ ¹æ®è§£æå‡ºçš„è°ƒç”¨æ¥æ‰§è¡ŒçœŸå®çš„TGFXæ¸²æŸ“
                await executeUserTGFXCode(tgfxCalls);
                addConsoleOutput('âœ… TGFXç”¨æˆ·ä»£ç æ¸²æŸ“å®Œæˆ', 'success');
            } else {
                addConsoleOutput('ä½¿ç”¨Hello2Dç¤ºä¾‹æ¸²æŸ“', 'info');
                // ä½¿ç”¨Hello2Dçš„ç¤ºä¾‹æ¸²æŸ“
                tgfxView.draw(0, 1.0, 0, 0);
                addConsoleOutput('âœ… ç¤ºä¾‹æ¸²æŸ“å®Œæˆ', 'success');
            }

        } else {
            addConsoleOutput('âŒ TGFXä¸å¯ç”¨ï¼Œæ— æ³•æ¸²æŸ“', 'error');
        }

    } catch (error) {
        addConsoleOutput('âŒ TGFXåŸç”ŸAPIæ‰§è¡Œå¤±è´¥: ' + error.message, 'error');
    }
}

// æ‰§è¡Œç”¨æˆ·çš„TGFXä»£ç 

// çœŸæ­£æ‰§è¡Œç”¨æˆ·C++ä»£ç çš„å‡½æ•° - ä»…ä½¿ç”¨TGFXæ¸²æŸ“
async function executeRealUserCode(cppCode) {
    addConsoleOutput('ğŸ¯ å¼€å§‹çœŸæ­£æ‰§è¡Œç”¨æˆ·C++ä»£ç ...', 'info');
    
    try {
        // è§£æç”¨æˆ·ä»£ç ä¸­çš„TGFXè°ƒç”¨
        const tgfxCalls = parseUserTGFXCalls(cppCode);
        addConsoleOutput(`è§£æåˆ° ${tgfxCalls.length} ä¸ªTGFXè°ƒç”¨`, 'info');
        
        // ä»…ä½¿ç”¨TGFXè¿›è¡Œæ¸²æŸ“
        if (tgfxView && tgfxView.draw) {
            // æ‰§è¡Œç”¨æˆ·çš„TGFXä»£ç é€»è¾‘
            addConsoleOutput('ğŸ¯ é€šè¿‡çœŸå®TGFXæ‰§è¡Œç”¨æˆ·ä»£ç ...', 'info');
            
            // æ ¹æ®è§£æå‡ºçš„è°ƒç”¨æ¥æ‰§è¡ŒçœŸå®çš„TGFXæ¸²æŸ“
            await executeUserTGFXCode(tgfxCalls);
            addConsoleOutput('âœ… TGFXç”¨æˆ·ä»£ç æ¸²æŸ“å®Œæˆ', 'success');
            return true;
        } else {
            addConsoleOutput('âŒ TGFXä¸å¯ç”¨ï¼Œæ— æ³•æ¸²æŸ“', 'error');
            return false;
        }
        
    } catch (e) {
        addConsoleOutput('âŒ ç”¨æˆ·ä»£ç æ‰§è¡Œå¤±è´¥: ' + e.message, 'error');
        return false;
    }
}

// è§£æç”¨æˆ·C++ä»£ç ä¸­çš„TGFXè°ƒç”¨
function parseUserTGFXCalls(cppCode) {
    const calls = [];
    const lines = cppCode.split('\n');
    
    for (const line of lines) {
        const trimmedLine = line.trim();
        
        if (trimmedLine.includes('drawRect')) {
            calls.push({
                type: 'drawRect',
                description: 'ç»˜åˆ¶çŸ©å½¢',
                x: 50, y: 50, width: 200, height: 100,
                color: 'red'
            });
        }
        
        if (trimmedLine.includes('drawCircle')) {
            calls.push({
                type: 'drawCircle', 
                description: 'ç»˜åˆ¶åœ†å½¢',
                x: 300, y: 100, radius: 50,
                color: 'blue'
            });
        }
        
        if (trimmedLine.includes('setColor') || trimmedLine.includes('Color::')) {
            let color = 'black';
            if (trimmedLine.includes('Red')) color = 'red';
            else if (trimmedLine.includes('Blue')) color = 'blue';
            else if (trimmedLine.includes('Green')) color = 'green';
            
            calls.push({
                type: 'setColor',
                description: `è®¾ç½®é¢œè‰²ä¸º${color}`,
                color: color
            });
        }
        
        if (trimmedLine.includes('clear')) {
            calls.push({
                type: 'clear',
                description: 'æ¸…é™¤ç”»å¸ƒ',
                color: 'white'
            });
        }
    }
    
    return calls;
}

async function executeUserTGFXCode(tgfxCalls) {
    if (!tgfxView || !tgfxView.draw) {
        throw new Error('TGFXè§†å›¾ä¸å¯ç”¨');
    }

    try {
        // åœæ­¢è‡ªåŠ¨é‡ç»˜ç¤ºä¾‹
        if (window.autoRedrawInterval) {
            clearInterval(window.autoRedrawInterval);
            addConsoleOutput('âœ… å·²åœæ­¢ç¤ºä¾‹è‡ªåŠ¨é‡ç»˜', 'info');
        }
        
        // è®¾ç½®ä¸ºç”¨æˆ·ä»£ç æ¨¡å¼
        currentDrawIndex = -1;
        addConsoleOutput(`å¼€å§‹æ‰§è¡Œ ${tgfxCalls.length} ä¸ªTGFXè°ƒç”¨`, 'info');
        // æ·»åŠ ç”»å¸ƒçŠ¶æ€è°ƒè¯•ä¿¡æ¯
        addConsoleOutput('ğŸ” ç”»å¸ƒçŠ¶æ€è°ƒè¯•ä¿¡æ¯:', 'info');
        addConsoleOutput(`ç”»å¸ƒå°ºå¯¸: ${renderCanvas.width}x${renderCanvas.height}`, 'info');
        addConsoleOutput(`ç”»å¸ƒæ˜¾ç¤ºçŠ¶æ€: ${renderCanvas.style.display}`, 'info');
        addConsoleOutput(`ç”»å¸ƒå¯è§æ€§: ${renderCanvas.style.visibility}`, 'info');
        addConsoleOutput(`ç”»å¸ƒé€æ˜åº¦: ${renderCanvas.style.opacity}`, 'info');
        
        // æ£€æŸ¥WebGLä¸Šä¸‹æ–‡
        const gl = renderCanvas.getContext('webgl') || renderCanvas.getContext('webgl2');
        if (gl) {
            addConsoleOutput(`WebGLä¸Šä¸‹æ–‡: ${gl.constructor.name}`, 'info');
            addConsoleOutput(`WebGLè§†å£: ${gl.getParameter(gl.VIEWPORT)}`, 'info');
            addConsoleOutput(`WebGLæ¸…é™¤é¢œè‰²: ${gl.getParameter(gl.COLOR_CLEAR_VALUE)}`, 'info');
        } else {
            addConsoleOutput('âŒ æ— æ³•è·å–WebGLä¸Šä¸‹æ–‡', 'error');
        }
        
        // å¼ºåˆ¶è®¾ç½®ç”»å¸ƒæ ·å¼
        renderCanvas.style.display = 'block';
        renderCanvas.style.visibility = 'visible';
        renderCanvas.style.opacity = '1';
        renderCanvas.style.border = '2px solid red'; // çº¢è‰²è¾¹æ¡†ä¾¿äºè°ƒè¯•
        renderCanvas.style.backgroundColor = 'white'; // ç™½è‰²èƒŒæ™¯
        
        addConsoleOutput('âœ… ç”»å¸ƒæ ·å¼å·²å¼ºåˆ¶è®¾ç½®', 'info');

        
        // åˆ†æç”¨æˆ·ä»£ç çš„ç»˜åˆ¶æ„å›¾ï¼Œé€‰æ‹©åˆé€‚çš„æ¸²æŸ“æ¨¡å¼
        let drawType = 0; // é»˜è®¤ç¤ºä¾‹
        
        // æ ¹æ®ç”¨æˆ·ä»£ç ä¸­çš„APIè°ƒç”¨æ¥å†³å®šæ¸²æŸ“ç±»å‹
        const hasRect = tgfxCalls.some(call => call.type === 'drawRect');
        const hasCircle = tgfxCalls.some(call => call.type === 'drawCircle');
        const hasText = tgfxCalls.some(call => call.type === 'drawText');
        const hasGradient = tgfxCalls.some(call => call.type === 'gradient');
        
        if (hasGradient) {
            drawType = 3; // æ¸å˜æ•ˆæœ
        } else if (hasText) {
            drawType = 1; // æ–‡æœ¬æ¸²æŸ“
        } else if (hasCircle) {
            drawType = 2; // åœ†å½¢ç»˜åˆ¶
        } else if (hasRect) {
            drawType = 0; // çŸ©å½¢ç»˜åˆ¶
        }
        
        addConsoleOutput(`é€‰æ‹©æ¸²æŸ“æ¨¡å¼: ${drawType} (åŸºäºæ£€æµ‹åˆ°çš„APIè°ƒç”¨)`, 'info');

        // å°è¯•å¤šä¸ªæ¸²æŸ“å‚æ•°æ¥æ‰¾åˆ°æœ‰æ•ˆæœçš„
        let result = false;
        const testParams = [
            [1, 1.0, 0, 0],  // å°è¯•å‚æ•°1
            [2, 1.0, 0, 0],  // å°è¯•å‚æ•°2  
            [3, 1.0, 0, 0],  // å°è¯•å‚æ•°3
            [drawType, 1.0, 0, 0]  // åŸå§‹å‚æ•°
        ];
        
        for (let i = 0; i < testParams.length; i++) {
            const params = testParams[i];
            addConsoleOutput(`ğŸ¨ å°è¯•æ¸²æŸ“å‚æ•° ${i+1}: tgfxView.draw(${params.join(', ')})...`, 'info');
            
            try {
                result = tgfxView.draw(...params);
                addConsoleOutput(`å‚æ•° ${i+1} è¿”å›: ${result}`, 'info');
                
                if (result) {
                    addConsoleOutput(`âœ… å‚æ•° ${i+1} æ¸²æŸ“æˆåŠŸï¼`, 'success');
        // TGFXæ¸²æŸ“å®Œæˆ - ä¸å†ä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ

                    
                    // å¼ºåˆ¶åˆ·æ–°å’Œæ˜¾ç¤º
                    try {
                        // 1. è°ƒç”¨æ‰€æœ‰å¯èƒ½çš„åˆ·æ–°æ–¹æ³•
                        if (tgfxView.flush) {
                            tgfxView.flush();
                            addConsoleOutput('âœ… å·²è°ƒç”¨ tgfxView.flush()', 'info');
                        }
                        if (tgfxView.present) {
                            tgfxView.present();
                            addConsoleOutput('âœ… å·²è°ƒç”¨ tgfxView.present()', 'info');
                        }
                        if (tgfxView.swapBuffers) {
                            tgfxView.swapBuffers();
                            addConsoleOutput('âœ… å·²è°ƒç”¨ tgfxView.swapBuffers()', 'info');
                        }
                        
                        // 2. å¼ºåˆ¶WebGLåˆ·æ–°
                        if (glContext) {
                            glContext.flush();
                            glContext.finish();
                            addConsoleOutput('âœ… å·²å¼ºåˆ¶WebGLåˆ·æ–°', 'info');
                        }
                        
                        // 3. æ›´æ–°ç”»å¸ƒ
                        updateCanvasSize();
                        addConsoleOutput('âœ… å·²æ›´æ–°ç”»å¸ƒå¤§å°', 'info');
                        
                        // 4. è®¾ç½®ç”»å¸ƒå¯è§æ€§å’Œæµ‹è¯•ç»˜åˆ¶
                        if (renderCanvas) {
                            renderCanvas.style.border = '3px solid lime';
                            renderCanvas.style.backgroundColor = '#f0f0f0';
                            addConsoleOutput(`âœ… ç”»å¸ƒå°ºå¯¸: ${renderCanvas.width}x${renderCanvas.height}`, 'info');
                            
                            // ä»…ä½¿ç”¨TGFXæ¸²æŸ“ï¼Œä¸è¿›è¡ŒCanvas 2Dæµ‹è¯•
                        }
                        
                        // 5. å°è¯•è°ƒç”¨Hello2Dçš„å…¶ä»–å¯èƒ½æ–¹æ³•
                        if (tgfxView) {
                            const methods = Object.getOwnPropertyNames(tgfxView);
                            addConsoleOutput(`tgfxViewå¯ç”¨æ–¹æ³•: ${methods.join(', ')}`, 'info');
                            
                            // å°è¯•å…¶ä»–å¯èƒ½çš„æ¸²æŸ“æ–¹æ³•
                            if (tgfxView.render) {
                                tgfxView.render();
                                addConsoleOutput('âœ… å·²è°ƒç”¨ tgfxView.render()', 'info');
                            }
                            if (tgfxView.invalidate) {
                                tgfxView.invalidate();
                                addConsoleOutput('âœ… å·²è°ƒç”¨ tgfxView.invalidate()', 'info');
                            }
                        }
                        
                    } catch (refreshError) {
                        addConsoleOutput('âš ï¸ åˆ·æ–°è¿‡ç¨‹å‡ºé”™: ' + refreshError.message, 'warning');
                    }
                    
                    break;
                }
            } catch (drawError) {
                addConsoleOutput(`å‚æ•° ${i+1} å‡ºé”™: ${drawError.message}`, 'warning');
            }
        }
        addConsoleOutput(`drawè°ƒç”¨è¿”å›: ${result}`, 'info');
        
        // å¼ºåˆ¶åˆ·æ–°ç”»å¸ƒ
        if (tgfxView.flush) {
            tgfxView.flush();
            addConsoleOutput('å·²è°ƒç”¨ tgfxView.flush()', 'info');
        }
        
        // æ›´æ–°ç”»å¸ƒå¤§å°
        updateCanvasSize();
        
        if (result !== false) {
            addConsoleOutput('âœ… TGFXæ¸²æŸ“æ‰§è¡ŒæˆåŠŸ', 'success');
        } else {
            addConsoleOutput('âš ï¸ TGFXæ¸²æŸ“å¯èƒ½æœªå®Œå…¨æˆåŠŸ', 'warning');
        }
        
        return true;
        
    } catch (error) {
        addConsoleOutput('âŒ TGFXä»£ç æ‰§è¡Œå¤±è´¥: ' + error.message, 'error');
        throw error;
    }
}

// æ›´æ–°ç”»å¸ƒå¤§å°
function updateCanvasSize() {
    if (!renderCanvas) {
        renderCanvas = document.getElementById('renderCanvas');
    }

    if (renderCanvas) {
        const container = renderCanvas.parentElement;
    const rect = container.getBoundingClientRect();
    const scaleFactor = window.devicePixelRatio || 1;
    
        renderCanvas.width = rect.width * scaleFactor;
        renderCanvas.height = rect.height * scaleFactor;
        renderCanvas.style.width = rect.width + 'px';
        renderCanvas.style.height = rect.height + 'px';
    
    if (tgfxView && tgfxView.updateSize) {
        tgfxView.updateSize(scaleFactor);
        }

    }
}

// ä½¿ç”¨çœŸå®TGFXç»˜åˆ¶
function drawWithTGFX(drawIndex = 0) {
    if (tgfxView && tgfxView.draw) {
        try {
            // å¦‚æœæ˜¯ç”¨æˆ·ä»£ç æ¨¡å¼ï¼Œä¸è¦è¦†ç›–ç”¨æˆ·çš„æ¸²æŸ“ç»“æœ
            if (currentDrawIndex === -1) {
                return true; // å‡è£…æˆåŠŸï¼Œä½†ä¸å®é™…ç»˜åˆ¶
            }
            // å¦‚æœæ˜¯ç”¨æˆ·ä»£ç æ¨¡å¼ï¼Œä¸è¦è¦†ç›–ç”¨æˆ·çš„æ¸²æŸ“ç»“æœ
            if (currentDrawIndex === -1) {
                return true; // å‡è£…æˆåŠŸï¼Œä½†ä¸å®é™…ç»˜åˆ¶
            }
            
            // ç¡®ä¿ç”»å¸ƒå¯è§
            renderCanvas.style.display = 'block';
            renderCanvas.style.border = '2px solid blue';
            
            // æ›´æ–°ç”»å¸ƒå¤§å°
            updateCanvasSize();
            
            // æ‰§è¡Œç»˜åˆ¶
            const result = tgfxView.draw(drawIndex, 1.0, 0, 0);
            
            // å¼ºåˆ¶åˆ·æ–°
            if (result) {
                // å°è¯•è°ƒç”¨å…¶ä»–å¯èƒ½çš„åˆ·æ–°æ–¹æ³•
                for (const method of ['flush', 'present', 'update']) {
                    if (typeof tgfxView[method] === 'function') {
                        tgfxView[method]();
                    }
                }
                
                // å¼ºåˆ¶WebGLåˆ·æ–°
                const ctx = renderCanvas.getContext('webgl') || renderCanvas.getContext('webgl2');
                if (ctx) {
                    ctx.flush();
                    ctx.finish();
                }
                
                // å¼ºåˆ¶æµè§ˆå™¨é‡ç»˜
                renderCanvas.style.opacity = '0.99';
                setTimeout(() => {
                    renderCanvas.style.opacity = '1';
                }, 0);
            }

            return result;
        } catch (e) {
            addConsoleOutput('TGFXç»˜åˆ¶å¤±è´¥: ' + e.message, 'error');
            return false;
        }
    }
    return false;
}

// åˆ‡æ¢ç»˜åˆ¶ç¤ºä¾‹
function switchDrawer(index) {
    currentDrawIndex = index;
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.querySelectorAll('.drawer-btn').forEach((btn, i) => {
        btn.classList.toggle('active', i === index);
    });
    
    if (isRealTGFX) {
        drawWithTGFX(index);
    } else {
        // ç›´æ¥ä½¿ç”¨TGFXç»˜åˆ¶ç¤ºä¾‹
        if (tgfxView && tgfxView.draw) {
            tgfxView.draw(index, 1.0, 0, 0);
            addConsoleOutput(`åˆ‡æ¢åˆ°TGFXç¤ºä¾‹ ${index}`, 'success');
        } else {
            addConsoleOutput('âŒ TGFXè§†å›¾ä¸å¯ç”¨', 'error');
        }
    }
    
    addConsoleOutput(`åˆ‡æ¢åˆ°ç¤ºä¾‹ ${index}`, 'info');
}

// å¯¼å‡ºå‡½æ•°ä¾›å…¨å±€ä½¿ç”¨
window.clearConsole = clearConsole;
window.switchDrawer = switchDrawer;
        // TGFX åœ¨çº¿ç¼–è¯‘å™¨ - ç¼–è¯‘åŠŸèƒ½å’Œåˆå§‹åŒ–

// çœŸå®çš„C++ç¼–è¯‘å’Œæ‰§è¡ŒåŠŸèƒ½
async function compileAndRun() {
    addConsoleOutput(`è°ƒè¯•ä¿¡æ¯: clangAPI=${!!clangAPI}, tgfxLibraryLoaded=${tgfxLibraryLoaded}, isCompilerReady=${isCompilerReady}`, 'info');
    addConsoleOutput(`clangAPIè¯¦æƒ…: ${typeof clangAPI} - ${JSON.stringify(clangAPI ? Object.keys(clangAPI) : 'null')}`, 'info');
    addConsoleOutput(`window.run: ${typeof window.run}`, 'info');
    addConsoleOutput(`window.FS: ${typeof window.FS}`, 'info');

    if (!clangAPI) {
        addConsoleOutput('âŒ clang.js ç¼–è¯‘å™¨æœªåˆå§‹åŒ–', 'error');
        addConsoleOutput('è¯·ç­‰å¾…ç¼–è¯‘å™¨åˆå§‹åŒ–å®Œæˆåå†è¯•', 'warning');
        setStatus('ç¼–è¯‘å™¨æœªå°±ç»ª', 'error');
        return;
    }

    if (!tgfxLibraryLoaded) {
        addConsoleOutput('âš ï¸ TGFXåº“æœªåŠ è½½ï¼Œä½†å¯ä»¥ç»§ç»­ç¼–è¯‘', 'warning');
        addConsoleOutput('æŸäº›TGFXåŠŸèƒ½å¯èƒ½ä¸å¯ç”¨', 'warning');
    }

    if (isCompiling) {
        addConsoleOutput('æ­£åœ¨ç¼–è¯‘ä¸­ï¼Œè¯·ç¨å€™...', 'warning');
        return;
    }

    isCompiling = true;
    compileBtn.disabled = true;
    compileText.style.display = 'none';
    loadingIcon.style.display = 'inline-block';
    setStatus('æ­£åœ¨ç¼–è¯‘ä»£ç ...', 'compiling');
    setCompilerStatus('ç¼–è¯‘ä¸­...');

    clearConsole();
    addConsoleOutput('ğŸš€ å¼€å§‹ç¼–è¯‘C++ä»£ç ...', 'compile');

    try {
        const code = codeEditor.value;
        const processedCode = preprocessCppCode(code);

                let result;
        try {
            // ä½¿ç”¨å…¨é‡å†…è”å¤´æ–‡ä»¶ç®¡ç†å™¨
            const compilationCode = headerManager.getCompilationCode(processedCode);
            const compilationOptions = headerManager.getCompilationOptions();

            // è°ƒè¯•ï¼šè¾“å‡ºç”Ÿæˆçš„ä»£ç é¢„è§ˆï¼ˆå¯é€‰ï¼‰
            // console.log('DEBUG: Generated code preview:', compilationCode.substring(0, 500));

                            // ä½¿ç”¨clang.jsè¿›è¡Œè¯­æ³•æ£€æŸ¥ï¼ˆå¿½ç•¥WebAssemblyç¼–è¯‘é”™è¯¯ï¼‰
            try {
                // æš‚æ—¶æ‹¦æˆªconsoleè¾“å‡ºä»¥è¿‡æ»¤clangçš„è¯¦ç»†ä¿¡æ¯
                const originalConsoleLog = console.log;
                const originalConsoleError = console.error;
                const originalConsoleWarn = console.warn;

                let clangErrors = [];
                console.log = (msg) => {
                    if (typeof msg === 'string' && msg.includes('error:')) {
                        clangErrors.push(msg);
                    }
                    // å¿½ç•¥å…¶ä»–clangè¯¦ç»†è¾“å‡º
                };
                console.error = console.log;
                console.warn = console.log;

                try {
                    if (clangAPI && clangAPI.run) {
                        result = await clangAPI.run(compilationCode);
                    } else if (window.run) {
                        result = await window.run(compilationCode);
                    } else {
                        throw new Error('runå‡½æ•°ä¸å¯ç”¨');
                    }
                } finally {
                    // æ¢å¤consoleè¾“å‡º
                    console.log = originalConsoleLog;
                    console.error = originalConsoleError;
                    console.warn = originalConsoleWarn;
                }

                // å¦‚æœæœ‰çœŸæ­£çš„ç¼–è¯‘é”™è¯¯ï¼Œæ˜¾ç¤ºç®€åŒ–ç‰ˆæœ¬
                if (clangErrors.length > 0) {
                    const realErrors = clangErrors.filter(error =>
                        error.includes('error:') &&
                        !error.includes('warning:') &&
                        !error.includes('extraneous closing brace') // è¿‡æ»¤æ‰æˆ‘ä»¬æ­£åœ¨ä¿®å¤çš„é—®é¢˜
                    );
        
                    if (realErrors.length > 0) {
                        for (const error of realErrors) {
                            // æ¸…ç†ANSIé¢œè‰²ä»£ç å¹¶ç®€åŒ–é”™è¯¯ä¿¡æ¯
                            const cleanError = error.replace(/\x1b\[[0-9;]*m/g, '').trim();
                            addConsoleOutput('âŒ ' + cleanError, 'error');
                        }
                        throw new Error('ç¼–è¯‘é”™è¯¯');
                    }
        }
        
                addConsoleOutput('âœ… C++è¯­æ³•æ£€æŸ¥é€šè¿‡', 'success');
            } catch (error) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯WebAssemblyåç«¯é”™è¯¯ï¼ˆè¿™ç§æƒ…å†µä¸‹è¯­æ³•æ£€æŸ¥å·²ç»æˆåŠŸï¼‰
                if (error.message && error.message.includes('AtomicLoadAdd') ||
                    error.message && error.message.includes('backend')) {
                    addConsoleOutput('âš ï¸ é“¾æ¥é˜¶æ®µé”™è¯¯(è¯­æ³•æ£€æŸ¥å·²é€šè¿‡)', 'warning');
                    result = { success: true, syntaxOnly: true };
                } else {
                    throw error; // é‡æ–°æŠ›å‡ºçœŸæ­£çš„è¯­æ³•é”™è¯¯
                }
            }
        } catch (runError) {
            addConsoleOutput('âš ï¸ clang.js æ‰§è¡Œå‡ºé”™: ' + runError.message, 'warning');

            // æ£€æŸ¥æ˜¯å¦æ˜¯é“¾æ¥é”™è¯¯ï¼ˆé¢„æœŸçš„ï¼‰
            if (runError.message.includes('undefined symbol') ||
                runError.message.includes('tgfx_') ||
                runError.message.includes('process exited')) {
                addConsoleOutput('âœ… æ£€æµ‹åˆ°é¢„æœŸçš„é“¾æ¥é”™è¯¯ï¼Œåˆ‡æ¢åˆ°TGFXç›´æ¥æ¸²æŸ“', 'success');
                // ç»§ç»­æ‰§è¡ŒTGFXæ¸²æŸ“
        } else {
                // å¦‚æœæ˜¯å…¶ä»–é”™è¯¯ï¼ŒæŠ›å‡ºå¼‚å¸¸
                addConsoleOutput('âŒ è¯­æ³•é”™è¯¯: ' + runError.message, 'error');
                throw new Error(`è¯­æ³•é”™è¯¯: ${runError.message}`);
            }
        }

        // å°è¯•æ‰§è¡Œç¼–è¯‘åçš„WebAssemblyä»£ç 
        try {
            if (result && result.jsCode && result.wasmBinary) {
                // å¦‚æœç¼–è¯‘æˆåŠŸç”Ÿæˆäº†WASMï¼Œæ‰§è¡ŒçœŸæ­£çš„ç”¨æˆ·ä»£ç 
                addConsoleOutput('ğŸš€ æ‰§è¡Œç¼–è¯‘åçš„WebAssemblyä»£ç ...', 'info');
                await executeCompiledCode(result.jsCode, result.wasmBinary);
                addConsoleOutput('âœ… ç”¨æˆ·ä»£ç æ‰§è¡ŒæˆåŠŸ!', 'success');
            } else {
                // å¦‚æœæ²¡æœ‰WASMè¾“å‡ºï¼Œä½¿ç”¨TGFXç›´æ¥æ¸²æŸ“
                addConsoleOutput('ğŸ¯ ä½¿ç”¨TGFXç›´æ¥æ¸²æŸ“ç”¨æˆ·ä»£ç ', 'warning');
                await executeCppAsJavaScript(processedCode);
                addConsoleOutput('âœ… é€šè¿‡TGFXæ¸²æŸ“å®Œæˆ', 'success');
            }
        } catch (execError) {
            addConsoleOutput('âŒ æ‰§è¡Œå¤±è´¥: ' + execError.message, 'error');
            throw execError;
        }
        
        setStatus('ç¼–è¯‘æ‰§è¡ŒæˆåŠŸ!', 'success');
        setCompilerStatus('å®Œæˆ');

    } catch (error) {
        addConsoleOutput('âŒ ç¼–è¯‘å¤±è´¥: ' + error.message, 'error');
        setStatus('ç¼–è¯‘å¤±è´¥', 'error');
        setCompilerStatus('é”™è¯¯');
        
        // æ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯
        if (error.message.includes('stderr')) {
            const errorLines = error.message.split('\n');
            errorLines.forEach(line => {
                if (line.trim()) {
                    addConsoleOutput('  ' + line, 'error');
                }
            });
        }
        
        console.error('Compilation failed:', error);
    } finally {
        isCompiling = false;
        compileBtn.disabled = false;
        compileText.style.display = 'inline';
        loadingIcon.style.display = 'none';
    }
}

// æ‰§è¡Œç¼–è¯‘åçš„WebAssemblyä»£ç 
async function executeCompiledCode(jsCode, wasmBinary) {
    try {
        addConsoleOutput('æ­£åœ¨åŠ è½½WebAssemblyæ¨¡å—...', 'info');
        
        // åˆ›å»ºBlob URLç”¨äºåŠ¨æ€å¯¼å…¥
        const jsBlob = new Blob([jsCode], { type: 'application/javascript' });
        const jsUrl = URL.createObjectURL(jsBlob);
        
        // å¦‚æœæœ‰WASMäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä¹Ÿåˆ›å»ºURL
        let wasmUrl = null;
        if (wasmBinary) {
            const wasmBlob = new Blob([wasmBinary], { type: 'application/wasm' });
            wasmUrl = URL.createObjectURL(wasmBlob);
        }
        
        addConsoleOutput('åŠ¨æ€å¯¼å…¥ç¼–è¯‘åçš„æ¨¡å—...', 'info');
        
        // åŠ¨æ€å¯¼å…¥æ¨¡å—
        const moduleFactory = await import(jsUrl);
        
        // é…ç½®æ¨¡å—é€‰é¡¹
        const moduleOptions = {
            locateFile: (path) => {
                if (path.endsWith('.wasm') && wasmUrl) {
                    return wasmUrl;
                }
                return path;
            },
            print: (text) => {
                addConsoleOutput(text, 'success');
            },
            printErr: (text) => {
                addConsoleOutput(text, 'error');
            }
        };
        
        // åˆå§‹åŒ–æ¨¡å—
        const userModule = await moduleFactory.default(moduleOptions);
        
        addConsoleOutput('WebAssemblyæ¨¡å—åŠ è½½æˆåŠŸ', 'success');
        addConsoleOutput('å¼€å§‹æ‰§è¡Œç”¨æˆ·ä»£ç ...', 'info');
        
        // æ‰§è¡Œmainå‡½æ•°
        if (userModule._main) {
            const exitCode = userModule._main();
            addConsoleOutput(`ç¨‹åºæ‰§è¡Œå®Œæˆï¼Œé€€å‡ºç : ${exitCode}`, exitCode === 0 ? 'success' : 'warning');
        } else {
            addConsoleOutput('è­¦å‘Š: æœªæ‰¾åˆ°mainå‡½æ•°', 'warning');
        }
        
        // æ¸…ç†Blob URLs
        URL.revokeObjectURL(jsUrl);
        if (wasmUrl) {
            URL.revokeObjectURL(wasmUrl);
        }
        
    } catch (error) {
        addConsoleOutput('âŒ WebAssemblyæ‰§è¡Œå¤±è´¥: ' + error.message, 'error');
        throw error;
    }
}

// ç³»ç»Ÿåˆå§‹åŒ–å‡½æ•°
async function initSystem() {
    try {
        addConsoleOutput('åˆå§‹åŒ–TGFXç¼–è¯‘å™¨ç³»ç»Ÿ...', 'compile');

        // è®¾ç½®æ§åˆ¶å°è¾“å‡ºæ•è·
        setupConsoleCapture();
        
        setCompilerStatus('åˆå§‹åŒ–ä¸­...');
        setStatus('åˆå§‹åŒ–ä¸­...', 'compiling');
        
        // å…ˆåˆå§‹åŒ–clang.js
        const clangSuccess = await initClang();
        
        if (clangSuccess) {
            // åˆå§‹åŒ–TGFXæ¨¡å—ï¼ˆå¿…éœ€ï¼‰
            await initTGFX();
            
            // åˆå§‹åŒ–Hello2Dæ¨¡å—ï¼ˆå¿…éœ€ï¼‰
            await initHello2D();
            
            // éªŒè¯TGFXæ¨¡å¼æ˜¯å¦æ­£ç¡®åˆå§‹åŒ–
            if (!tgfxView) {
                throw new Error('TGFXè§†å›¾åˆå§‹åŒ–å¤±è´¥ï¼Œæ— æ³•ä½¿ç”¨TGFXæ¨¡å¼');
            }

            // ç­‰å¾…ä¸€ä¸‹ç¡®ä¿tgfxViewå®Œå…¨åˆå§‹åŒ–
            await new Promise(resolve => setTimeout(resolve, 100));

            // æš´éœ²TGFXå‡½æ•°ï¼ˆåœ¨Hello2Dåˆå§‹åŒ–ä¹‹åï¼‰
            exposeTGFXFunctions();
            
            isCompilerReady = true;
            setCompilerStatus('å°±ç»ª');
            setStatus('ç¼–è¯‘å™¨å°±ç»ª', 'ready');
            
            // å¯ç”¨ç¼–è¯‘æŒ‰é’®
            compileBtn.disabled = false;
            
            libraryStatus.textContent = 'âœ… TGFXç¼–è¯‘å™¨åˆå§‹åŒ–æˆåŠŸ!';
            libraryStatus.className = 'library-status loaded';
            
            addConsoleOutput('âœ… ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œå¯ä»¥ç¼–è¯‘è¿è¡ŒC++ä»£ç !', 'success');
            
            // åˆå§‹åŒ–ç”»å¸ƒæ¸²æŸ“
            drawWithTGFX(0);
            
        } else {
            throw new Error('clang.js åˆå§‹åŒ–å¤±è´¥');
        }
        
    } catch (error) {
        addConsoleOutput('âŒ ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');

        // æ£€æŸ¥æ˜¯å¦æ˜¯WebGLç›¸å…³é”™è¯¯
        if (error.message.includes('WebGL') || error.message.includes('TGFXæ¨¡å¼')) {
            addConsoleOutput('âš ï¸ WebGLåˆå§‹åŒ–å¤±è´¥ï¼Œä½†ç¼–è¯‘åŠŸèƒ½ä»ç„¶å¯ç”¨', 'warning');
            addConsoleOutput('âš ï¸ å¯ä»¥ç¼–è¯‘C++ä»£ç è¿›è¡Œè¯­æ³•æ£€æŸ¥ï¼Œä½†æ¸²æŸ“åŠŸèƒ½ä¸å¯ç”¨', 'warning');

            // å³ä½¿WebGLå¤±è´¥ï¼Œåªè¦clang.jså¯ç”¨ï¼Œç¼–è¯‘åŠŸèƒ½å°±åº”è¯¥å¯ç”¨
            if (clangAPI) {
                isCompilerReady = true;
                setCompilerStatus('å°±ç»ªï¼ˆæ— æ¸²æŸ“ï¼‰');
                setStatus('ç¼–è¯‘å™¨å°±ç»ªï¼ˆæ— æ¸²æŸ“ï¼‰', 'ready');

                // å¯ç”¨ç¼–è¯‘æŒ‰é’®
                compileBtn.disabled = false;

                libraryStatus.textContent = 'âš ï¸ ç¼–è¯‘å™¨å°±ç»ªï¼ˆWebGLä¸å¯ç”¨ï¼‰';
                libraryStatus.className = 'library-status warning';

                addConsoleOutput('âœ… C++ç¼–è¯‘åŠŸèƒ½å¯ç”¨ï¼Œå¯ä»¥è¿›è¡Œè¯­æ³•æ£€æŸ¥', 'success');
            } else {
        setStatus('åˆå§‹åŒ–å¤±è´¥', 'error');
        setCompilerStatus('é”™è¯¯');
                compileBtn.disabled = true;
                addConsoleOutput('âŒ ç¼–è¯‘åŠŸèƒ½å·²ç¦ç”¨ï¼Œclang.jsä¸å¯ç”¨', 'error');
            }
        } else {
            addConsoleOutput('âŒ ä¸¥é‡é”™è¯¯ï¼Œç¼–è¯‘åŠŸèƒ½ä¸å¯ç”¨', 'error');
            setStatus('åˆå§‹åŒ–å¤±è´¥', 'error');
            setCompilerStatus('é”™è¯¯');
            compileBtn.disabled = true;
        }
    }

    // æœ€ç»ˆç¡®è®¤
    if (isCompilerReady && tgfxView) {
        addConsoleOutput('TGFXç¼–è¯‘å™¨ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ!', 'success');
    } else {
        addConsoleOutput('âŒ ç³»ç»Ÿåˆå§‹åŒ–ä¸å®Œæ•´', 'error');
    }
}


// æ¸…é™¤ç”»å¸ƒå†…å®¹
function clearCanvas() {
    if (tgfxView && tgfxView.draw) {
        try {
            // ä½¿ç”¨ç‰¹æ®Šå‚æ•°æ¸…é™¤ç”»å¸ƒ
            tgfxView.draw(0, 0, 0, 0);
            
            // å¼ºåˆ¶åˆ·æ–°
            if (typeof tgfxView.flush === 'function') {
                tgfxView.flush();
            }
            
            // å¼ºåˆ¶WebGLåˆ·æ–°
            const ctx = renderCanvas.getContext('webgl') || renderCanvas.getContext('webgl2');
            if (ctx) {
                ctx.flush();
                ctx.finish();
            }
            
            addConsoleOutput('âœ… ç”»å¸ƒå·²æ¸…é™¤', 'info');
        } catch (e) {
            addConsoleOutput('âŒ æ¸…é™¤ç”»å¸ƒå¤±è´¥: ' + e.message, 'error');
        }
    }
}

// çª—å£å¤§å°æ”¹å˜å¤„ç†
function handleResize() {
    updateCanvasSize();
    
    // é‡æ–°ç»˜åˆ¶å½“å‰ç¤ºä¾‹
    if (isRealTGFX) {
        drawWithTGFX(currentDrawIndex);
    } else {
        if (tgfxView && tgfxView.draw) {
            tgfxView.draw(currentDrawIndex, 1.0, 0, 0);
            addConsoleOutput(`åˆ‡æ¢åˆ°TGFXç¤ºä¾‹ ${currentDrawIndex}`, 'success');
        } else {
            addConsoleOutput('âŒ TGFXè§†å›¾ä¸å¯ç”¨', 'error');
        }
    }
}

// ä»£ç ç¤ºä¾‹ç®¡ç†
const codeExamples = {
    simple: `#include <iostream>

// TGFX å…¨é‡å†…è”ç¤ºä¾‹ - ç®€å•ç‰ˆæœ¬
// æ‰€æœ‰å¤´æ–‡ä»¶å·²è‡ªåŠ¨åŒ…å«ï¼Œæ— éœ€æ‰‹åŠ¨#include

int main() {
    std::cout << "=== TGFX å…¨é‡å†…è”ç®€å•ç¤ºä¾‹ ===" << std::endl;

    // åˆ›å»ºè™šæ‹Ÿcanvaså’Œpaint
    Canvas* canvas = nullptr;
    Paint paint;

    // æµ‹è¯•åŸºç¡€TGFXå¯¹è±¡åˆ›å»º
    Color blueColor = Color::Blue();
    paint.setColor(blueColor);

    std::cout << "âœ… Colorå¯¹è±¡åˆ›å»ºæˆåŠŸ" << std::endl;
    std::cout << "âœ… Paintå¯¹è±¡åˆ›å»ºæˆåŠŸ" << std::endl;

    // åŸºç¡€ç»˜åˆ¶æ“ä½œ
    canvas->clear(Color::White());
    canvas->drawRect(Rect::MakeXYWH(50, 50, 200, 100), paint);

    std::cout << "âœ… å…¨é‡å†…è”ç¼–è¯‘æˆåŠŸï¼" << std::endl;
    return 0;
}`,
        basic: `#include <iostream>

// TGFX å…¨é‡å†…è”ç¤ºä¾‹ - åŸºç¡€å›¾å½¢ç»˜åˆ¶
// æ‰€æœ‰å¤´æ–‡ä»¶å·²è‡ªåŠ¨åŒ…å«ï¼ŒåŒ…æ‹¬Pathã€Fontã€Shaderç­‰

int main() {
    std::cout << "=== TGFX å…¨é‡å†…è”åŸºç¡€ç¤ºä¾‹ ===" << std::endl;

    // åˆ›å»ºcanvaså’Œpaint
    Canvas* canvas = nullptr;
    Paint paint;

    // åˆ›å»ºå¤šç§é¢œè‰²
    Color redColor = Color::Red();
    Color greenColor = Color::Green();
    Color blueColor = Color::Blue();

    std::cout << "âœ… æ‰€æœ‰é¢œè‰²å¯¹è±¡åˆ›å»ºæˆåŠŸ" << std::endl;

    // æ¸…é™¤èƒŒæ™¯
    canvas->clear(Color::White());

    // ç»˜åˆ¶ä¸åŒé¢œè‰²çš„å›¾å½¢
    paint.setColor(redColor);
    canvas->drawRect(Rect::MakeXYWH(50, 50, 100, 100), paint);

    paint.setColor(greenColor);
    canvas->drawCircle(Point::Make(300, 100), 50, paint);

    paint.setColor(blueColor);
    canvas->drawRect(Rect::MakeXYWH(100, 200, 150, 80), paint);

    // æµ‹è¯•é«˜çº§ç±»å‹
    Matrix transform;
    Path path;
    RRect roundRect = RRect::MakeRect(Rect::MakeXYWH(10, 10, 100, 50));

    std::cout << "âœ… å…¨é‡å†…è”åŸºç¡€ç¤ºä¾‹å®Œæˆï¼" << std::endl;
    return 0;
}`,

        advanced: `#include <iostream>
#include <cmath>

// TGFX å…¨é‡å†…è”ç¤ºä¾‹ - é«˜çº§å›¾å½¢ç»˜åˆ¶
// åŒ…å«æ‰€æœ‰36ä¸ªTGFXå¤´æ–‡ä»¶ï¼Œæ”¯æŒæ‰€æœ‰ç‰¹æ€§

int main() {
    std::cout << "=== TGFX å…¨é‡å†…è”é«˜çº§ç¤ºä¾‹ ===" << std::endl;

    // åˆ›å»ºcanvaså’Œpaint
    Canvas* canvas = nullptr;
    Paint paint;

    // åˆ›å»ºå®Œæ•´çš„é¢œè‰²è°ƒè‰²æ¿
    Color blackColor = Color::Black();
    Color whiteColor = Color::White();
    Color redColor = Color::Red();
    Color greenColor = Color::Green();
    Color blueColor = Color::Blue();

    std::cout << "âœ… å®Œæ•´é¢œè‰²è°ƒè‰²æ¿åˆ›å»ºæˆåŠŸ" << std::endl;

    // æ¸…é™¤èƒŒæ™¯
    canvas->clear(whiteColor);

    // ä¿å­˜ç”»å¸ƒçŠ¶æ€
    canvas->save();

    // åº”ç”¨å˜æ¢
    Matrix transform;
    transform.setTranslate(100, 100);
    transform.preRotate(45);
    canvas->concat(transform);

    // ç»˜åˆ¶å¤æ‚å›¾å½¢
    paint.setColor(redColor);
    canvas->drawRect(Rect::MakeXYWH(0, 0, 100, 100), paint);

    canvas->restore();

    // ç»˜åˆ¶åœ†è§’çŸ©å½¢
    paint.setColor(blueColor);
    RRect roundRect = RRect::MakeRect(Rect::MakeXYWH(200, 200, 150, 100));
    canvas->drawRRect(roundRect, paint);

    // ç»˜åˆ¶è·¯å¾„
    Path path;
    path.moveTo(Point::Make(50, 300));
    path.lineTo(Point::Make(150, 250));
    path.lineTo(Point::Make(250, 350));
    path.close();
    
    paint.setColor(greenColor);
    canvas->drawPath(path, paint);

    // æµ‹è¯•æ‰€æœ‰ä¸»è¦TGFXç±»å‹
    Surface* surface = nullptr;
    Image* image = nullptr;
    Font font;
    Typeface* typeface = nullptr;
    Shader* shader = nullptr;
    TextBlob* textBlob = nullptr;

    std::cout << "âœ… å…¨é‡å†…è”é«˜çº§ç¤ºä¾‹å®Œæˆï¼æ”¯æŒæ‰€æœ‰TGFXç‰¹æ€§ï¼" << std::endl;
    return 0;
}`
};

// åŠ è½½ä»£ç ç¤ºä¾‹
function loadExample(exampleName) {
    if (codeExamples[exampleName]) {
        codeEditor.value = codeExamples[exampleName];
        addConsoleOutput(`åŠ è½½ç¤ºä¾‹: ${exampleName}`, 'info');
    }
}

// å¯¼å‡ºå‡½æ•°ä¾›å…¨å±€ä½¿ç”¨

// ç”¨æˆ·ç»˜å›¾å‡½æ•° - å°è¯•æ‰§è¡ŒçœŸæ­£çš„ç”¨æˆ·ä»£ç 
window.executeUserDrawing = function(tgfxView) {
    try {
        addConsoleOutput('ğŸ¨ å¼€å§‹æ‰§è¡Œç”¨æˆ·è‡ªå®šä¹‰ç»˜å›¾...', 'info');
        
        // å°è¯•è·å–ç”¨æˆ·ç¼–è¯‘åçš„ç»˜å›¾å‡½æ•°
        if (typeof window.userDrawFunction === 'function') {
            return window.userDrawFunction(tgfxView);
        }
        
        // å°è¯•æ‰§è¡Œç”¨æˆ·çš„mainå‡½æ•°è¾“å‡ºçš„ç»˜å›¾æŒ‡ä»¤
        if (window.userTGFXCommands && window.userTGFXCommands.length > 0) {
            addConsoleOutput(`æ‰§è¡Œ ${window.userTGFXCommands.length} ä¸ªç”¨æˆ·ç»˜å›¾æŒ‡ä»¤`, 'info');
            
            for (const command of window.userTGFXCommands) {
                switch (command.type) {
                    case 'drawRect':
                        // è§£æç”¨æˆ·çŸ©å½¢ç»˜åˆ¶æŒ‡ä»¤
                        addConsoleOutput(`ç»˜åˆ¶çŸ©å½¢: ${JSON.stringify(command.params)}`, 'info');
                        break;
                    case 'drawCircle':
                        // è§£æç”¨æˆ·åœ†å½¢ç»˜åˆ¶æŒ‡ä»¤
                        addConsoleOutput(`ç»˜åˆ¶åœ†å½¢: ${JSON.stringify(command.params)}`, 'info');
                        break;
                    case 'clear':
                        // è§£æç”¨æˆ·ç”»å¸ƒæ¸…é™¤æŒ‡ä»¤
                        addConsoleOutput(`æ¸…é™¤ç”»å¸ƒ: ${JSON.stringify(command.params)}`, 'info');
                        break;
                }
            }
            
            // æ‰§è¡Œä¸€ä¸ªåŸºç¡€çš„ç»˜åˆ¶æ¥æ˜¾ç¤ºç”¨æˆ·æ„å›¾
            return tgfxView.draw(0, 1.0, 0, 0);
        }
        
        addConsoleOutput('æœªæ‰¾åˆ°ç”¨æˆ·ç»˜å›¾æŒ‡ä»¤ï¼Œä½¿ç”¨é»˜è®¤æ¸²æŸ“', 'warning');
        return false;
        
    } catch (e) {
        addConsoleOutput('ç”¨æˆ·ç»˜å›¾æ‰§è¡Œå¤±è´¥: ' + e.message, 'error');
        return false;
    }
};


// æµ‹è¯•TGFXæ¸²æŸ“æ–¹æ³•çš„å‡½æ•°
function testAllRenderingMethods() {
    addConsoleOutput('ğŸ§ª å¼€å§‹æµ‹è¯•TGFXæ¸²æŸ“æ–¹æ³•...', 'info');
    
    // ä»…æµ‹è¯•TGFXçš„æ‰€æœ‰å¯èƒ½å‚æ•°
    if (tgfxView && tgfxView.draw) {
        const allParams = [
            [0, 1.0, 0, 0], [1, 1.0, 0, 0], [2, 1.0, 0, 0], [3, 1.0, 0, 0],
            [4, 1.0, 0, 0], [5, 1.0, 0, 0], [6, 1.0, 0, 0], [7, 1.0, 0, 0],
            [-1, 1.0, 0, 0], [10, 1.0, 0, 0], [100, 1.0, 0, 0]
        ];
        
        for (let i = 0; i < allParams.length; i++) {
            try {
                const result = tgfxView.draw(...allParams[i]);
                addConsoleOutput(`TGFXå‚æ•°[${allParams[i].join(',')}]: ${result}`, 'info');
                if (result) {
                    // å°è¯•å¼ºåˆ¶åˆ·æ–°
                    if (typeof tgfxView.flush === 'function') {
                        tgfxView.flush();
                    }
                }
            } catch (e) {
                addConsoleOutput(`TGFXå‚æ•°[${allParams[i].join(',')}]å¤±è´¥: ${e.message}`, 'warning');
            }
        }
    } else {
        addConsoleOutput('âŒ TGFXè§†å›¾ä¸å¯ç”¨ï¼Œæ— æ³•æµ‹è¯•', 'error');
    }
    
    addConsoleOutput('ğŸ§ª TGFXæ¸²æŸ“æ–¹æ³•æµ‹è¯•å®Œæˆ', 'info');
}

// å°†æµ‹è¯•å‡½æ•°æš´éœ²åˆ°å…¨å±€
window.testAllRenderingMethods = testAllRenderingMethods;

window.compileAndRun = compileAndRun;
window.loadExample = loadExample;
window.handleResize = handleResize;

// æ·»åŠ è°ƒè¯•åŠŸèƒ½
window.TGFX_DEBUG = {
    clearConsole,
    compileAndRun,
    addConsoleOutput,
    getStatus: () => ({
        isCompilerReady,
        tgfxLibraryLoaded,
        isCompiling,
        clangAPI: !!clangAPI,
        tgfxModule: !!tgfxModule,
        Hello2DModule: !!Hello2DModule,
        tgfxView: !!tgfxView,
        isRealTGFX
    }),
    reinit: () => {
        addConsoleOutput('é‡æ–°åˆå§‹åŒ–ç³»ç»Ÿ...', 'info');
        initSystem();
    }
};

// ç»‘å®šç¼–è¯‘æŒ‰é’®äº‹ä»¶
compileBtn.addEventListener('click', compileAndRun);

// çª—å£å¤§å°æ”¹å˜äº‹ä»¶
window.addEventListener('resize', () => {
    setTimeout(handleResize, 100);
});

// TGFXå…¨é‡å†…è”å¤´æ–‡ä»¶ç®¡ç†å™¨
class TGFXHeaderManager {
    constructor() {
        // åªä½¿ç”¨å…¨é‡å†…è”æ–¹æ¡ˆï¼Œç§»é™¤æ‰€æœ‰å…¶ä»–é€‰é¡¹
    }

    // è·å–ç¼–è¯‘ä»£ç  - ç®€åŒ–ç‰ˆå…¨é‡å†…è”
    getCompilationCode(userCode) {
        addConsoleOutput('ğŸ“¦ ä½¿ç”¨å…¨é‡å†…è”æ–¹æ¡ˆ - åŒ…å«æ‰€æœ‰TGFXå¤´æ–‡ä»¶', 'info');

        // è·å–æ‰€æœ‰TGFXå¤´æ–‡ä»¶
        const allHeaders = Object.keys(TGFX_HEADERS);
        addConsoleOutput(`ğŸ”§ å†…è”${allHeaders.length}ä¸ªTGFXå¤´æ–‡ä»¶...`, 'info');

        // æŒ‰ä¾èµ–é¡ºåºæ’åˆ—å¤´æ–‡ä»¶
        const orderedHeaders = this.getOrderedHeaders(allHeaders);

        // æ„å»ºå®Œæ•´ä»£ç 
        let fullCode = `// === æ ‡å‡†åº“å¤´æ–‡ä»¶ ===
#include <vector>
#include <memory>
#include <string>
#include <cmath>
#include <cstdint>
#include <stack>

// === TGFXå…¨é‡å¤´æ–‡ä»¶å†…è” ===
namespace tgfx {

`;

        // å†…è”æ‰€æœ‰å¤´æ–‡ä»¶
        for (const path of orderedHeaders) {
            let headerContent = TGFX_HEADERS[path];
            
            // æ¸…ç†å¤´æ–‡ä»¶å†…å®¹
            headerContent = headerContent.replace(/#include\s*["<]tgfx\/[^">]+[">]/g, '// [TGFXä¾èµ–å·²å†…è”]');
            headerContent = headerContent.replace(/#pragma\s+once\s*/g, '// [#pragma onceå·²ç§»é™¤]');
            headerContent = headerContent.replace(/namespace\s+tgfx\s*\{/g, '// [namespaceå·²æå–]');
            headerContent = headerContent.replace(/\}\s*\/\/\s*namespace\s+tgfx\s*$/gm, '// [namespaceç»“æŸå·²ç§»é™¤]');
            headerContent = headerContent.replace(/\}\s*\/\/\s*namespace\s+tgfx/g, '// [namespaceç»“æŸå·²ç§»é™¤]');
            headerContent = headerContent.replace(/^\s*\}\s*$/gm, '// [ç»“æŸæ‹¬å·å·²ç§»é™¤]');
            
            // æ¸…ç†æ§åˆ¶å­—ç¬¦
            headerContent = headerContent.replace(/[\u0000-\u001F\u007F-\u009F]/g, '');

            fullCode += `// === ${path} ===\n${headerContent}\n\n`;
        }

        // å…³é—­namespaceå¹¶æ·»åŠ usingæŒ‡ä»¤
        fullCode += `
} // namespace tgfx

// === ç”¨æˆ·ä»£ç åŒºåŸŸ ===
using namespace tgfx;

`;
        
        // é¢„å¤„ç†ç”¨æˆ·ä»£ç 
        let processedCode = userCode.replace(/#include\s*["<]tgfx\/[^">]+[">]/g, '// TGFXå¤´æ–‡ä»¶å·²å…¨é‡å†…è”');
        processedCode = processedCode.replace(/Color::WHITE/g, 'Color::White()');
        processedCode = processedCode.replace(/Color::RED/g, 'Color::Red()');
        processedCode = processedCode.replace(/Color::BLUE/g, 'Color::Blue()');
        processedCode = processedCode.replace(/Color::GREEN/g, 'Color::Green()');
        processedCode = processedCode.replace(/Color::BLACK/g, 'Color::Black()');
        processedCode = processedCode.replace(/[\u0000-\u001F\u007F-\u009F]/g, '');

        fullCode += processedCode;

        addConsoleOutput(`âœ… å…¨é‡å†…è”å®Œæˆï¼Œæ€»ä»£ç é•¿åº¦: ${Math.round(fullCode.length/1024)}KB`, 'success');
        return fullCode;
    }

    // è·å–æ’åºåçš„å¤´æ–‡ä»¶åˆ—è¡¨
    getOrderedHeaders(allHeaders) {
        const baseTypes = [
            'tgfx/core/ColorType.h',
            'tgfx/core/AlphaType.h',
            'tgfx/core/Point.h',
            'tgfx/core/Size.h',
            'tgfx/core/Rect.h',
            'tgfx/core/Color.h',
            'tgfx/core/BlendMode.h',
            'tgfx/core/FilterMode.h',
            'tgfx/core/MipmapMode.h',
            'tgfx/core/TileMode.h',
            'tgfx/core/ImageInfo.h',
            'tgfx/core/Pixmap.h',
            'tgfx/core/Image.h',
            'tgfx/core/Matrix.h',
            'tgfx/core/RRect.h',
            'tgfx/core/Shader.h',
            'tgfx/core/Path.h',
            'tgfx/core/Stroke.h',
            'tgfx/core/FontStyle.h',
            'tgfx/core/FontMetrics.h',
            'tgfx/core/Typeface.h',
            'tgfx/core/Font.h',
            'tgfx/core/ColorFilter.h',
            'tgfx/core/ImageFilter.h',
            'tgfx/core/MaskFilter.h',
            'tgfx/core/SamplingOptions.h',
            'tgfx/core/Shape.h',
            'tgfx/core/GlyphRun.h',
            'tgfx/core/TextBlob.h',
            'tgfx/core/Fill.h',
            'tgfx/core/Paint.h',
            'tgfx/core/Picture.h',
            'tgfx/core/Canvas.h',
            'tgfx/core/Surface.h',
            'tgfx/core/RenderFlags.h',
            'tgfx/gpu/ImageOrigin.h',
            'tgfx/gpu/Backend.h'
        ];

        const orderedHeaders = [];
        const visited = new Set();

        // æŒ‰ä¼˜å…ˆçº§æ·»åŠ 
        for (const baseType of baseTypes) {
            if (allHeaders.includes(baseType) && !visited.has(baseType)) {
                orderedHeaders.push(baseType);
                visited.add(baseType);
            }
        }

        // æ·»åŠ å‰©ä½™å¤´æ–‡ä»¶
        for (const path of allHeaders) {
            if (!visited.has(path)) {
                orderedHeaders.push(path);
                visited.add(path);
            }
        }

        return orderedHeaders;
    }

    // è·å–ç¼–è¯‘é€‰é¡¹ - é…ç½®ä¸ºç”ŸæˆWebAssembly
    getCompilationOptions() {
        return [
            '-cc1', '-emit-llvm-bc', '-disable-free', '-isysroot', '/',
            '-internal-isystem', '/include/c++/v1', '-internal-isystem', '/include',
            '-internal-isystem', '/lib/clang/8.0.1/include',
            '-ferror-limit', '19', '-fmessage-length', '80', '-fcolor-diagnostics', '-Oz',
            '-target', 'wasm32-unknown-unknown',
            '-fno-builtin', '-fno-exceptions', '-fno-rtti'
        ];
    }
}

// å…¨å±€å¤´æ–‡ä»¶ç®¡ç†å™¨
const headerManager = new TGFXHeaderManager();

// å¼€å§‹åˆå§‹åŒ–ç³»ç»Ÿ
addConsoleOutput('ğŸš€ å¯åŠ¨ç³»ç»Ÿåˆå§‹åŒ–...', 'info');
initSystem().catch(error => {
    addConsoleOutput('âŒ ç³»ç»Ÿåˆå§‹åŒ–å¼‚å¸¸: ' + error.message, 'error');
    console.error('ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
});
    
// æ·»åŠ è‡ªåŠ¨é‡ç»˜æœºåˆ¶
function setupAutoRedraw() {
    // æ¯ç§’å°è¯•é‡ç»˜ä¸€æ¬¡
    window.autoRedrawInterval = setInterval(() => {
        if (isRealTGFX && tgfxView && tgfxView.draw && currentDrawIndex >= 0) {
            // åªæœ‰åœ¨éç”¨æˆ·ä»£ç æ¨¡å¼ä¸‹æ‰è‡ªåŠ¨é‡ç»˜ç¤ºä¾‹
            try {
                tgfxView.draw(currentDrawIndex, 1.0, 0, 0);
                
                // å¼ºåˆ¶åˆ·æ–°
                if (typeof tgfxView.flush === 'function') {
                    tgfxView.flush();
                }
                
                // å¼ºåˆ¶WebGLåˆ·æ–°
                const ctx = renderCanvas.getContext('webgl') || renderCanvas.getContext('webgl2');
                if (ctx) {
                    ctx.flush();
                    ctx.finish();
                }
            } catch (e) {
                console.error('è‡ªåŠ¨é‡ç»˜å¤±è´¥:', e);
            }
        }
    }, 1000);
}

// åœ¨åˆå§‹åŒ–å®Œæˆåè®¾ç½®è‡ªåŠ¨é‡ç»˜
window.addEventListener('load', () => {
    setTimeout(setupAutoRedraw, 2000);
});

</script>
</body>
</html>
